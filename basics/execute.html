<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Execution messsages - Sylvia book</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Guide to building CosmWasm smart contracts">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Getting started</li><li class="chapter-item expanded "><a href="../setting-up-env.html"><strong aria-hidden="true">1.</strong> Setting up the environment</a></li><li class="chapter-item expanded "><a href="../wasmd-quick-start.html"><strong aria-hidden="true">2.</strong> Quick start with wasmd</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../wasmd-quick-start/testnet.html"><strong aria-hidden="true">2.1.</strong> Testnet setup</a></li><li class="chapter-item expanded "><a href="../wasmd-quick-start/preparing-account.html"><strong aria-hidden="true">2.2.</strong> Preparing account</a></li><li class="chapter-item expanded "><a href="../wasmd-quick-start/testnet-interaction.html"><strong aria-hidden="true">2.3.</strong> Interaction with testnet</a></li><li class="chapter-item expanded "><a href="../basics/building-contract.html"><strong aria-hidden="true">2.4.</strong> Building the contract</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Smart contracts</li><li class="chapter-item expanded "><a href="../basics.html"><strong aria-hidden="true">3.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basics/create-project.html"><strong aria-hidden="true">3.1.</strong> Create a Rust project</a></li><li class="chapter-item expanded "><a href="../basics/entry-points.html"><strong aria-hidden="true">3.2.</strong> Entry points</a></li><li class="chapter-item expanded "><a href="../basics/first-messages.html"><strong aria-hidden="true">3.3.</strong> Generating first messages</a></li><li class="chapter-item expanded "><a href="../basics/state.html"><strong aria-hidden="true">3.4.</strong> Contract state</a></li><li class="chapter-item expanded "><a href="../basics/query.html"><strong aria-hidden="true">3.5.</strong> Creating a query</a></li><li class="chapter-item expanded "><a href="../basics/query-testing.html"><strong aria-hidden="true">3.6.</strong> Testing a query</a></li><li class="chapter-item expanded "><a href="../basics/multitest-intro.html"><strong aria-hidden="true">3.7.</strong> Introducing multitest</a></li><li class="chapter-item expanded "><a href="../basics/execute.html" class="active"><strong aria-hidden="true">3.8.</strong> Execution messsages</a></li><li class="chapter-item expanded "><a href="../basics/events.html"><strong aria-hidden="true">3.9.</strong> Events attributes and data</a></li><li class="chapter-item expanded "><a href="../basics/funds.html"><strong aria-hidden="true">3.10.</strong> Dealing with funds</a></li><li class="chapter-item expanded "><a href="../basics/good-practices.html"><strong aria-hidden="true">3.11.</strong> Good practices</a></li><li class="chapter-item expanded "><a href="../basics/fp-types.html"><strong aria-hidden="true">3.12.</strong> Floating point types</a></li><li class="chapter-item expanded "><a href="../basics/reusability.html"><strong aria-hidden="true">3.13.</strong> Reusability</a></li></ol></li><li class="chapter-item expanded "><a href="../actor-model.html"><strong aria-hidden="true">4.</strong> The Actor Model</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../actor-model/idea.html"><strong aria-hidden="true">4.1.</strong> The idea</a></li><li class="chapter-item expanded "><a href="../actor-model/actors-in-blockchain.html"><strong aria-hidden="true">4.2.</strong> Actors in the blockchain</a></li><li class="chapter-item expanded "><a href="../actor-model/contract-as-actor.html"><strong aria-hidden="true">4.3.</strong> Contract as an actor</a></li></ol></li><li class="chapter-item expanded "><a href="../impressum.html">Legal Information</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Sylvia book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="execution-messages"><a class="header" href="#execution-messages">Execution messages</a></h1>
<p>We created <code>instantiate</code> and <code>query</code> messages. We have the state in our contract and can test it.
Now let's expand our contract by adding the possibility of updating the state. In this chapter, we
will add the <code>add_member</code> execute message.</p>
<h2 id="custom-error"><a class="header" href="#custom-error">Custom error</a></h2>
<p>Because we don't want non-admins to add new admins to our contract, we will have to take some steps
to prevent it. In case of a call from non-admin we want to return an error that will inform the
users that they are not authorized to perform this kind of operation on contract.
We will achieve this goal by creating our custom error type. It will have to implement
<a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a><StdError> trait to be compatible
with most of the error cases in our contract. It will also have an <code>Unauthorized</code> variant.</p>
<p>First, let's update our <code>Cargo.toml</code> with a new dependency to
<a href="https://docs.rs/thiserror/latest/thiserror/"><code>thiserror</code></a>.</p>
<pre><code class="language-rust noplayground">[package]
name = &quot;contract&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[lib]
crate-type = [&quot;cdylib&quot;]

[features]
library = []

[dependencies]
cosmwasm-std = { version = &quot;1.1&quot;, features = [&quot;staking&quot;] }
cosmwasm-schema = &quot;1.1.6&quot;
serde = { version = &quot;1.0.147&quot;, features = [&quot;derive&quot;] }
sylvia = &quot;0.2.1&quot;
schemars = &quot;0.8.11&quot;
cw-storage-plus = &quot;0.16.0&quot;
thiserror = &quot;1.0.37&quot;

[dev-dependencies]
anyhow = &quot;1&quot;
cw-multi-test = &quot;0.16&quot;
</code></pre>
<p>This error provides us with a derive macro which, we will use to implement our <code>ContractError</code>.
Let's add a new module to our <code>src/lib.rs</code>:</p>
<pre><code class="language-rust noplayground">pub mod contract;
pub mod error;
pub mod responses;

#[cfg(test)]
mod multitest;
<span class="boring">
</span><span class="boring">use contract::{ContractError, ContractQueryMsg};
</span><span class="boring">use cosmwasm_std::{entry_point, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};
</span><span class="boring">
</span><span class="boring">use crate::contract::{AdminContract, InstantiateMsg};
</span><span class="boring">
</span><span class="boring">const CONTRACT: AdminContract = AdminContract::new();
</span><span class="boring">
</span><span class="boring">#[entry_point]
</span><span class="boring">pub fn instantiate(
</span><span class="boring">   deps: DepsMut,
</span><span class="boring">   env: Env,
</span><span class="boring">   info: MessageInfo,
</span><span class="boring">   msg: InstantiateMsg,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">   msg.dispatch(&amp;CONTRACT, (deps, env, info))
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[entry_point]
</span><span class="boring">pub fn query(deps: Deps, env: Env, msg: ContractQueryMsg) -&gt; Result&lt;Binary, ContractError&gt; {
</span><span class="boring">   msg.dispatch(&amp;CONTRACT, (deps, env))
</span><span class="boring">}
</span>
</code></pre>
<p>And now, let's create <code>src/error.rs</code>:</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::{Addr, StdError};
use thiserror::Error;

#[derive(Error, Debug, PartialEq)]
pub enum ContractError {
    #[error(&quot;{0}&quot;)]
    Std(#[from] StdError),
    #[error(&quot;{sender} is not a contract admin&quot;)]
    Unauthorized { sender: Addr },
}
</code></pre>
<p>Our custom error will derive the following traits:</p>
<ul>
<li><a href="https://docs.rs/thiserror/latest/thiserror/derive.Error.html"><code>Error</code></a></li>
<li><code>Debug</code> - for testing purposes</li>
<li><code>PartialEq</code> - for testing purposes</li>
</ul>
<p><code>#[error(_)]</code> will generate Display implementation for our variants. In case of
<code>StdError</code> we want only to forward the error message. In case of our custom <code>Unauthorized</code> variant
user will receive information about who sent the message and why it failed.</p>
<h2 id="impl-execute-message"><a class="header" href="#impl-execute-message">Impl execute message</a></h2>
<p>With the error created, let's implement the message.
It will add a new admin if the sender is an admin.</p>
<pre><code class="language-rust noplayground">use crate::error::ContractError;
use crate::responses::AdminListResp;
use cosmwasm_std::{Addr, Deps, DepsMut, Empty, Env, MessageInfo, Order, Response, StdResult};
use cw_storage_plus::Map;
use schemars;
use sylvia::contract;

<span class="boring">pub struct AdminContract&lt;'a&gt; {
</span><span class="boring">   pub(crate) admins: Map&lt;'a, &amp;'a Addr, Empty&gt;,
</span><span class="boring">}
</span>
#[contract]
impl AdminContract&lt;'_&gt; {
<span class="boring">   pub const fn new() -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">           admins: Map::new(&quot;admins&quot;),
</span><span class="boring">       }
</span><span class="boring">   }
</span>    ...

    #[msg(instantiate)]
    pub fn instantiate(
        &amp;self,
        ctx: (DepsMut, Env, MessageInfo),
        admins: Vec&lt;String&gt;,
    ) -&gt; Result&lt;Response, ContractError&gt; {
        let (deps, _, _) = ctx;

        for admin in admins {
            let admin = deps.api.addr_validate(&amp;admin)?;
            self.admins.save(deps.storage, &amp;admin, &amp;Empty {})?;
        }

        Ok(Response::new())
    }
<span class="boring">
</span><span class="boring">   #[msg(query)]
</span><span class="boring">   pub fn admin_list(&amp;self, ctx: (Deps, Env)) -&gt; StdResult&lt;AdminListResp&gt; {
</span><span class="boring">       let (deps, _) = ctx;
</span><span class="boring">
</span><span class="boring">       let admins: Result&lt;_, _&gt; = self
</span><span class="boring">           .admins
</span><span class="boring">           .keys(deps.storage, None, None, Order::Ascending)
</span><span class="boring">           .map(|addr| addr.map(String::from))
</span><span class="boring">           .collect();
</span><span class="boring">
</span><span class="boring">       Ok(AdminListResp { admins: admins? })
</span><span class="boring">   }
</span>
    #[msg(exec)]
    pub fn add_member(
        &amp;self,
        ctx: (DepsMut, Env, MessageInfo),
        admin: String,
    ) -&gt; Result&lt;Response, ContractError&gt; {
        let (deps, _, info) = ctx;

        if !self.admins.has(deps.storage, &amp;info.sender) {
            return Err(ContractError::Unauthorized {
                sender: info.sender,
            });
        }
        let admin = deps.api.addr_validate(&amp;admin)?;
        self.admins.save(deps.storage, &amp;admin, &amp;Empty {})?;

        Ok(Response::new())
    }
}

#[cfg(test)]
<span class="boring">mod tests {
</span><span class="boring">   use crate::entry_points::{instantiate, query};
</span><span class="boring">   use cosmwasm_std::from_binary;
</span><span class="boring">   use cosmwasm_std::testing::{mock_dependencies, mock_env, mock_info};
</span><span class="boring">
</span><span class="boring">   use super::*;
</span><span class="boring">
</span><span class="boring">   #[test]
</span><span class="boring">   fn admin_list_query() {
</span><span class="boring">       let mut deps = mock_dependencies();
</span><span class="boring">       let env = mock_env();
</span><span class="boring">
</span><span class="boring">       instantiate(
</span><span class="boring">           deps.as_mut(),
</span><span class="boring">           env.clone(),
</span><span class="boring">           mock_info(&quot;sender&quot;, &amp;[]),
</span><span class="boring">           InstantiateMsg {
</span><span class="boring">               admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">           },
</span><span class="boring">       )
</span><span class="boring">       .unwrap();
</span><span class="boring">
</span><span class="boring">       let msg = QueryMsg::AdminList {};
</span><span class="boring">       let resp = query(deps.as_ref(), env, ContractQueryMsg::AdminContract(msg)).unwrap();
</span><span class="boring">       let resp: AdminListResp = from_binary(&amp;resp).unwrap();
</span><span class="boring">       assert_eq!(
</span><span class="boring">           resp,
</span><span class="boring">           AdminListResp {
</span><span class="boring">               admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">           }
</span><span class="boring">       );
</span><span class="boring">   }
</span><span class="boring">}
</span></code></pre>
<p>First, let's add the <code>ContractError</code> to <code>src/contract.rs</code> and delete the old alias. We will update
<code>instantiate</code> to return it instead of the <code>StdError</code>. In the case of a <code>query</code> it is mostly
unnecessary as we rarely check anything in it, but if you have a reason you can also update it. It
is a good approach to define your error type and return it in all but <code>query</code> messages.</p>
<p>To generate <code>execute</code> message we will prefix it with <code>#[msg(exec)]</code>. The return type is the same as
in case of <code>instantiate</code> which is <code>Result&lt;Response, ContractError&gt;</code>.
We will acquire the sender from <code>MessageInfo</code>. In case sender is unathorized a non-admin we
will return its Addr in <code>ContractError::Unauthorized</code>.
Because we can't be sure if the address sent by the admin is correct and represent the actual <code>Addr</code>
in a blockchain we must first call the <code>addr_validate</code> on it. If it's correct we can save it and
return <code>Ok(Response)</code>.</p>
<h2 id="update-entry-points"><a class="header" href="#update-entry-points">Update entry points</a></h2>
<p>Now that we have created the <code>ExecMsg</code>, let's add a new entry point. We have to do it only once
per every type of message, thanks to the dispatch method.</p>
<pre><code class="language-rust noplayground">pub mod contract;
pub mod error;
pub mod responses;

#[cfg(test)]
mod multitest;

use cosmwasm_std::{entry_point, Binary, Deps, DepsMut, Env, MessageInfo, Response};

use crate::contract::{AdminContract, ContractExecMsg, ContractQueryMsg, InstantiateMsg};
use crate::error::ContractError;

const CONTRACT: AdminContract = AdminContract::new();

#[entry_point]
pub fn instantiate(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: InstantiateMsg,
) -&gt; Result&lt;Response, ContractError&gt; {
    msg.dispatch(&amp;CONTRACT, (deps, env, info))
}

#[entry_point]
pub fn query(deps: Deps, env: Env, msg: ContractQueryMsg) -&gt; Result&lt;Binary, ContractError&gt; {
    msg.dispatch(&amp;CONTRACT, (deps, env))
}

#[entry_point]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ContractExecMsg,
) -&gt; Result&lt;Response, ContractError&gt; {
    msg.dispatch(&amp;CONTRACT, (deps, env, info))
}
</code></pre>
<p>Nothing new here. We have the same <code>deps</code>, <code>env</code>, and <code>info</code> variables in the signature as in the
case of <code>instantiate</code>. Our message is <code>ContractExecMsg</code> similar to <code>ContractQueryMsg</code> in case of the
<code>query</code>. The body of the function is simply a <code>dispatch</code> call on the <code>msg</code>. We also updated
instantiate to return <code>ContractError</code>.</p>
<h2 id="unit-testing"><a class="header" href="#unit-testing">Unit testing</a></h2>
<p>Now let's add a simple unit test for <code>execute</code> message.</p>
<pre><code class="language-rust noplayground"><span class="boring">use crate::error::ContractError;
</span><span class="boring">use crate::responses::AdminListResp;
</span><span class="boring">use cosmwasm_std::{Addr, Deps, DepsMut, Empty, Env, MessageInfo, Order, Response, StdResult};
</span><span class="boring">use cw_storage_plus::Map;
</span><span class="boring">use schemars;
</span><span class="boring">use sylvia::contract;
</span><span class="boring">
</span><span class="boring">pub struct AdminContract&lt;'a&gt; {
</span><span class="boring">   pub(crate) admins: Map&lt;'a, &amp;'a Addr, Empty&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[contract]
</span><span class="boring">impl AdminContract&lt;'_&gt; {
</span><span class="boring">   pub const fn new() -&gt; Self {
</span><span class="boring">       Self {
</span><span class="boring">           admins: Map::new(&quot;admins&quot;),
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[msg(instantiate)]
</span><span class="boring">   pub fn instantiate(
</span><span class="boring">       &amp;self,
</span><span class="boring">       ctx: (DepsMut, Env, MessageInfo),
</span><span class="boring">       admins: Vec&lt;String&gt;,
</span><span class="boring">   ) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">       let (deps, _, _) = ctx;
</span><span class="boring">
</span><span class="boring">       for admin in admins {
</span><span class="boring">           let admin = deps.api.addr_validate(&amp;admin)?;
</span><span class="boring">           self.admins.save(deps.storage, &amp;admin, &amp;Empty {})?;
</span><span class="boring">       }
</span><span class="boring">
</span><span class="boring">       Ok(Response::new())
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[msg(query)]
</span><span class="boring">   pub fn admin_list(&amp;self, ctx: (Deps, Env)) -&gt; StdResult&lt;AdminListResp&gt; {
</span><span class="boring">       let (deps, _) = ctx;
</span><span class="boring">
</span><span class="boring">       let admins: Result&lt;_, _&gt; = self
</span><span class="boring">           .admins
</span><span class="boring">           .keys(deps.storage, None, None, Order::Ascending)
</span><span class="boring">           .map(|addr| addr.map(String::from))
</span><span class="boring">           .collect();
</span><span class="boring">
</span><span class="boring">       Ok(AdminListResp { admins: admins? })
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[msg(exec)]
</span><span class="boring">   pub fn add_member(
</span><span class="boring">       &amp;self,
</span><span class="boring">       ctx: (DepsMut, Env, MessageInfo),
</span><span class="boring">       admin: String,
</span><span class="boring">   ) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">       let (deps, _, info) = ctx;
</span><span class="boring">
</span><span class="boring">       if !self.admins.has(deps.storage, &amp;info.sender) {
</span><span class="boring">           return Err(ContractError::Unauthorized {
</span><span class="boring">               sender: info.sender,
</span><span class="boring">           });
</span><span class="boring">       }
</span><span class="boring">       let admin = deps.api.addr_validate(&amp;admin)?;
</span><span class="boring">
</span><span class="boring">       self.admins.save(deps.storage, &amp;admin, &amp;Empty {})?;
</span><span class="boring">
</span><span class="boring">       Ok(Response::new().add_attribute(&quot;action&quot;, &quot;add_member&quot;))
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
<span class="boring">mod tests {
</span>    ...
    
<span class="boring">   use crate::entry_points::{execute, instantiate, query};
</span><span class="boring">   use cosmwasm_std::from_binary;
</span><span class="boring">   use cosmwasm_std::testing::{mock_dependencies, mock_env, mock_info};
</span><span class="boring">
</span><span class="boring">   use super::*;
</span><span class="boring">
</span><span class="boring">   #[test]
</span><span class="boring">   fn admin_list_query() {
</span><span class="boring">       let mut deps = mock_dependencies();
</span><span class="boring">       let env = mock_env();
</span><span class="boring">
</span><span class="boring">       instantiate(
</span><span class="boring">           deps.as_mut(),
</span><span class="boring">           env.clone(),
</span><span class="boring">           mock_info(&quot;sender&quot;, &amp;[]),
</span><span class="boring">           InstantiateMsg {
</span><span class="boring">               admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">           },
</span><span class="boring">       )
</span><span class="boring">       .unwrap();
</span><span class="boring">
</span><span class="boring">       let msg = QueryMsg::AdminList {};
</span><span class="boring">       let resp = query(deps.as_ref(), env, ContractQueryMsg::AdminContract(msg)).unwrap();
</span><span class="boring">       let resp: AdminListResp = from_binary(&amp;resp).unwrap();
</span><span class="boring">       assert_eq!(
</span><span class="boring">           resp,
</span><span class="boring">           AdminListResp {
</span><span class="boring">               admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">           }
</span><span class="boring">       );
</span><span class="boring">   }
</span><span class="boring">
</span>    #[test]
    fn add_member() {
        let mut deps = mock_dependencies();
        let env = mock_env();

        instantiate(
            deps.as_mut(),
            env.clone(),
            mock_info(&quot;sender&quot;, &amp;[]),
            InstantiateMsg {
                admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
            },
        )
        .unwrap();

        let info = mock_info(&quot;admin1&quot;, &amp;[]);
        let msg = ExecMsg::AddMember {
            admin: &quot;admin3&quot;.to_owned(),
        };
        execute(deps.as_mut(), env.clone(), info, ContractExecMsg::AdminContract(msg)).unwrap();

        let msg = QueryMsg::AdminList {};
        let resp = query(deps.as_ref(), env, ContractQueryMsg::AdminContract(msg)).unwrap();
        let resp: AdminListResp = from_binary(&amp;resp).unwrap();
        assert_eq!(
            resp,
            AdminListResp {
                admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned(), &quot;admin3&quot;.to_owned()],
            }
        );
    }
}
</code></pre>
<p>It is very similar to the <code>query</code> test. The difference is the call to the <code>execute</code> entry point with
<code>ContractExecMsg</code>. We created another <code>mock_info</code> instead of reusing one from instantiate because in
a real life scenario <code>MessageInfo</code> is created for every message.</p>
<h2 id="multitest"><a class="header" href="#multitest">Multitest</a></h2>
<p>We have <code>ExecMsg</code> created, the entry point is established for it and we have simple unit test
checking if &quot;Ok case&quot; is working. Time to test it in the <code>multitest</code> enviroment.
First, we will update our proxy. This time we only need to add a call to the <code>add_member</code>.</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::{Addr, StdResult};
use cw_multi_test::{App, AppResponse, Executor};

use crate::{
    contract::{AdminContract, ExecMsg, InstantiateMsg, QueryMsg},
    error::ContractError,
    responses::AdminListResp,
};

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
<span class="boring">pub struct AdminContractCodeId(u64);
</span><span class="boring">
</span><span class="boring">impl AdminContractCodeId {
</span><span class="boring">   pub fn store_code(app: &amp;mut App) -&gt; Self {
</span><span class="boring">       let code_id = app.store_code(Box::new(AdminContract::new()));
</span><span class="boring">       Self(code_id)
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[track_caller]
</span><span class="boring">   pub fn instantiate(
</span><span class="boring">       self,
</span><span class="boring">       app: &amp;mut App,
</span><span class="boring">       sender: &amp;Addr,
</span><span class="boring">       admins: Vec&lt;String&gt;,
</span><span class="boring">       label: &amp;str,
</span><span class="boring">       admin: Option&lt;String&gt;,
</span><span class="boring">   ) -&gt; Result&lt;AdminContractProxy, ContractError&gt; {
</span><span class="boring">       let msg = InstantiateMsg { admins };
</span><span class="boring">
</span><span class="boring">       app.instantiate_contract(self.0, sender.clone(), &amp;msg, &amp;[], label, admin)
</span><span class="boring">           .map_err(|err| err.downcast().unwrap())
</span><span class="boring">           .map(AdminContractProxy)
</span><span class="boring">   }
</span><span class="boring">}
</span>
#[derive(Debug)]
pub struct AdminContractProxy(Addr);

impl AdminContractProxy {
<span class="boring">   #[track_caller]
</span><span class="boring">   pub fn admin_list(&amp;self, app: &amp;App) -&gt; StdResult&lt;AdminListResp&gt; {
</span><span class="boring">       let msg = QueryMsg::AdminList {};
</span><span class="boring">
</span><span class="boring">       app.wrap().query_wasm_smart(self.0.clone(), &amp;msg)
</span><span class="boring">   }
</span><span class="boring">
</span>    #[track_caller]
    pub fn add_member(
        &amp;self,
        app: &amp;mut App,
        sender: &amp;Addr,
        admin: String,
    ) -&gt; Result&lt;AppResponse, ContractError&gt; {
        let msg = ExecMsg::AddMember { admin };

        app.execute_contract(sender.clone(), self.0.clone(), &amp;msg, &amp;[])
            .map_err(|err| err.downcast().unwrap())
    }
}
</code></pre>
<p>You can see that <code>App</code> will return a new type
<a href="https://docs.rs/cw-multi-test/latest/cw_multi_test/struct.AppResponse.html"><code>AppResponse</code></a> from
cw_multi_test rather then <code>Response</code>. As for the body of this method, it is important to pass
<code>sender</code> as <a href="https://docs.rs/cw-multi-test/latest/cw_multi_test/trait.Executor.html#method.execute_contract"><code>execute_contract</code></a> requires it.
We will again pass the empty slice as <code>funds</code> as we don't want to deal with it for now.
We call <code>map_err</code> here, trying to
<a href="https://docs.rs/anyhow/1.0.66/anyhow/struct.Error.html#method.downcast"><code>downcast</code></a> the error to
<code>ContractError</code>.</p>
<p>Now that proxy is ready, let's add a new multitest.
Our scenario will be an <code>error case</code>. An unauthorized user will try to add themselves as an admin
to the contract, which should fail.</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::Addr;
use cw_multi_test::App;

use crate::error::ContractError;
use crate::{multitest::proxy::AdminContractCodeId, responses::AdminListResp};

<span class="boring">#[test]
</span><span class="boring">fn basic() {
</span><span class="boring">   let mut app = App::default();
</span><span class="boring">
</span><span class="boring">   let owner = Addr::unchecked(&quot;addr0001&quot;);
</span><span class="boring">   let admin1 = Addr::unchecked(&quot;admin1&quot;);
</span><span class="boring">   let admin2 = Addr::unchecked(&quot;admin2&quot;);
</span><span class="boring">   let admin3 = Addr::unchecked(&quot;admin3&quot;);
</span><span class="boring">
</span><span class="boring">   let code_id = AdminContractCodeId::store_code(&amp;mut app);
</span><span class="boring">
</span><span class="boring">   let contract = code_id
</span><span class="boring">       .instantiate(
</span><span class="boring">           &amp;mut app,
</span><span class="boring">           &amp;owner,
</span><span class="boring">           vec![admin1.to_string(), admin2.to_string()],
</span><span class="boring">           &quot;Cw20 contract&quot;,
</span><span class="boring">           None,
</span><span class="boring">       )
</span><span class="boring">       .unwrap();
</span><span class="boring">
</span><span class="boring">   let resp = contract.admin_list(&amp;app).unwrap();
</span><span class="boring">
</span><span class="boring">   assert_eq!(
</span><span class="boring">       resp,
</span><span class="boring">       AdminListResp {
</span><span class="boring">           admins: vec![admin1.to_string(), admin2.to_string()]
</span><span class="boring">       }
</span><span class="boring">   );
</span><span class="boring">
</span><span class="boring">   contract
</span><span class="boring">       .add_member(&amp;mut app, &amp;admin1, admin3.to_string())
</span><span class="boring">       .unwrap();
</span><span class="boring">
</span><span class="boring">   let resp = contract.admin_list(&amp;app).unwrap();
</span><span class="boring">
</span><span class="boring">   assert_eq!(
</span><span class="boring">       resp,
</span><span class="boring">       AdminListResp {
</span><span class="boring">           admins: vec![admin1.to_string(), admin2.to_string(), admin3.to_string()]
</span><span class="boring">       }
</span><span class="boring">   );
</span><span class="boring">}
</span><span class="boring">
</span>#[test]
fn unathorized() {
    let mut app = App::default();

    let owner = Addr::unchecked(&quot;addr0001&quot;);
    let admin1 = Addr::unchecked(&quot;admin1&quot;);
    let admin2 = Addr::unchecked(&quot;admin2&quot;);
    let admin3 = Addr::unchecked(&quot;admin3&quot;);

    let code_id = AdminContractCodeId::store_code(&amp;mut app);

    let contract = code_id
        .instantiate(
            &amp;mut app,
            &amp;owner,
            vec![admin1.to_string(), admin2.to_string()],
            &quot;Cw20 contract&quot;,
            None,
        )
        .unwrap();

    let resp = contract.admin_list(&amp;app).unwrap();

    assert_eq!(
        resp,
        AdminListResp {
            admins: vec![admin1.to_string(), admin2.to_string()]
        }
    );

    let err = contract
        .add_member(&amp;mut app, &amp;admin3, admin3.to_string())
        .unwrap_err();

    assert_eq!(err, ContractError::Unauthorized { sender: admin3 });

    let resp = contract.admin_list(&amp;app).unwrap();

    assert_eq!(
        resp,
        AdminListResp {
            admins: vec![admin1.to_string(), admin2.to_string()]
        }
    );
}
</code></pre>
<p>Once again, as in the case of the unit test this is similiar to the <code>query</code> test.
After contract instantiation, we will call <code>add_member</code> with <code>admin3</code> as a sender and catch the error
using <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_err"><code>unwrap_err</code></a>. Then
we will use <code>assert_eq</code> to check if it is <code>ContractError::Unauthorized { sender: &quot;admin3&quot; }</code>.
In the end, we will query the contract for a list of admins, and <code>admin3</code> is not on the list.</p>
<p>Great our contract works as expected, but we could test more scenarios. I encourage
you to think of other edge cases and try to test them by yourself.
We can now add new admins to the contract, but some might want to leave this responsibility.
Try to add new message <code>leave</code> and don't forget to test the new functionality.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../basics/multitest-intro.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../basics/events.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../basics/multitest-intro.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../basics/events.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
