<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Sylvia book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Guide to building CosmWasm smart contracts">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Getting started</li><li class="chapter-item expanded "><a href="setting-up-env.html"><strong aria-hidden="true">1.</strong> Setting up the environment</a></li><li class="chapter-item expanded "><a href="wasmd-quick-start.html"><strong aria-hidden="true">2.</strong> Quick start with wasmd</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="wasmd-quick-start/testnet.html"><strong aria-hidden="true">2.1.</strong> Testnet setup</a></li><li class="chapter-item expanded "><a href="wasmd-quick-start/preparing-account.html"><strong aria-hidden="true">2.2.</strong> Preparing account</a></li><li class="chapter-item expanded "><a href="wasmd-quick-start/testnet-interaction.html"><strong aria-hidden="true">2.3.</strong> Interaction with testnet</a></li><li class="chapter-item expanded "><a href="basics/building-contract.html"><strong aria-hidden="true">2.4.</strong> Building the contract</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Smart contracts</li><li class="chapter-item expanded "><a href="basics.html"><strong aria-hidden="true">3.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basics/create-project.html"><strong aria-hidden="true">3.1.</strong> Create a Rust project</a></li><li class="chapter-item expanded "><a href="basics/entry-points.html"><strong aria-hidden="true">3.2.</strong> Entry points</a></li><li class="chapter-item expanded "><a href="basics/first-messages.html"><strong aria-hidden="true">3.3.</strong> Generating first messages</a></li><li class="chapter-item expanded "><a href="basics/state.html"><strong aria-hidden="true">3.4.</strong> Contract state</a></li><li class="chapter-item expanded "><a href="basics/query.html"><strong aria-hidden="true">3.5.</strong> Creating a query</a></li><li class="chapter-item expanded "><a href="basics/query-testing.html"><strong aria-hidden="true">3.6.</strong> Testing a query</a></li><li class="chapter-item expanded "><a href="basics/multitest-intro.html"><strong aria-hidden="true">3.7.</strong> Introducing multitest</a></li><li class="chapter-item expanded "><a href="basics/execute.html"><strong aria-hidden="true">3.8.</strong> Execution messsages</a></li><li class="chapter-item expanded "><a href="basics/events.html"><strong aria-hidden="true">3.9.</strong> Events attributes and data</a></li><li class="chapter-item expanded "><a href="basics/funds.html"><strong aria-hidden="true">3.10.</strong> Dealing with funds</a></li><li class="chapter-item expanded "><a href="basics/good-practices.html"><strong aria-hidden="true">3.11.</strong> Good practices</a></li><li class="chapter-item expanded "><a href="basics/fp-types.html"><strong aria-hidden="true">3.12.</strong> Floating point types</a></li><li class="chapter-item expanded "><a href="basics/reusability.html"><strong aria-hidden="true">3.13.</strong> Reusability</a></li></ol></li><li class="chapter-item expanded "><a href="actor-model.html"><strong aria-hidden="true">4.</strong> The Actor Model</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="actor-model/idea.html"><strong aria-hidden="true">4.1.</strong> The idea</a></li><li class="chapter-item expanded "><a href="actor-model/actors-in-blockchain.html"><strong aria-hidden="true">4.2.</strong> Actors in the blockchain</a></li><li class="chapter-item expanded "><a href="actor-model/contract-as-actor.html"><strong aria-hidden="true">4.3.</strong> Contract as an actor</a></li></ol></li><li class="chapter-item expanded "><a href="impressum.html">Legal Information</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Sylvia book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This book is a guide for creating CosmWasm smart contracts with Sylvia framework.
It will lead you step by step, and explain relevant topics from the easiest to the trickier
ones.</p>
<p>The idea of the book is not only to tell you about smart contracts API but also
to show you how to do it in a clean and maintainable way. We will show you
patterns that CosmWasm creators established and encouraged you to use.</p>
<p>This book is a redo of <a href="https://book.cosmwasm.com/">cosmwasm-book</a>.
To see advantage of using sylvia you can compare development of smart contracts
in both of these titles.</p>
<h2 id="prerequirements"><a class="header" href="#prerequirements">Prerequirements</a></h2>
<p>This book explores CosmWasm smart contracts. It is not a Rust tutorial, and it
assumes basic Rust knowledge. As you will probably learn it alongside this
book, I strongly recommend grasping the language itself first. You can find
great resources to start with Rust on <a href="https://www.rust-lang.org/learn">Learn
Rust</a> page.</p>
<h2 id="cosmwasm-api-documentation"><a class="header" href="#cosmwasm-api-documentation">CosmWasm API documentation</a></h2>
<p>This is the guide-like documentation. If you are looking for the API
documentation, you may be interested in checking one of the following:</p>
<ul>
<li><a href="https://crates.io/crates/cosmwasm-std">cosmwasm-std</a></li>
<li><a href="https://crates.io/crates/cw-storage-plus">cw-storage-plus</a></li>
<li><a href="https://crates.io/crates/cw-multi-test">cw-multi-test</a></li>
<li><a href="https://crates.io/crates/cw-utils">cw-utils</a></li>
<li><a href="https://crates.io/crates/sylvia">sylvia framework</a></li>
</ul>
<h2 id="contributing-to-the-book"><a class="header" href="#contributing-to-the-book">Contributing to the book</a></h2>
<p>This book is maintained on <a href="https://github.com/CosmWasm/sylvia-book">Github</a> and auto
deployed from there. Please create an
<a href="https://github.com/CosmWasm/sylvia-book/issues">issue</a> or pull request if you find
any mistakes, bugs, or ambiguities.</p>
<h2 id="warning"><a class="header" href="#warning">Warning</a></h2>
<p>This book is still under construction so be aware that in places it might feel a little bit disjointed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-the-environment"><a class="header" href="#setting-up-the-environment">Setting up the environment</a></h1>
<p>To work with CosmWasm smart contract, you will need rust installed on your
machine. If you don't have one, you can find installation instructions on <a href="https://www.rust-lang.org/tools/install">the
Rust website</a>.</p>
<p>I assume you are working with a stable Rust channel in this book.</p>
<p>Additionally, you will need the Wasm rust compiler backend installed to build
Wasm binaries. To install it, run:</p>
<pre><code>rustup target add wasm32-unknown-unknown
</code></pre>
<p>Optionally if you want to try out your contracts on a testnet, you will need a
<a href="https://github.com/CosmWasm/wasmd">wasmd</a> binary. We would focus on testing
contracts with Rust unit testing utility throughout the book, so it is not
required to follow. However, seeing the product working in a real-world
environment may be nice.</p>
<p>To install <code>wasmd</code>, first install the <a href="https://github.com/golang/go/wiki#working-with-go">golang</a>. Then
clone the <code>wasmd</code> and install it:</p>
<pre><code>$ git clone git@github.com:CosmWasm/wasmd.git
$ cd ./wasmd
$ make install
</code></pre>
<p>Also, to be able to upload Rust Wasm Contracts into the blockchain, you will need
to install <a href="https://www.docker.com/">docker</a>. To minimize your contract sizes,
it will be required to run CosmWasm Rust Optimizer; without that, more complex
contracts might exceed a size limit.</p>
<h2 id="check-contract-utility"><a class="header" href="#check-contract-utility">Check contract utility</a></h2>
<p>An additional helpful tool for building smart contracts is the <code>cosmwasm-check</code>
utility. It allows you to check if the wasm binary is a proper smart contract
ready to upload into the blockchain. You can install it using cargo:</p>
<pre><code>$ cargo install cosmwasm-check
</code></pre>
<p>If the installation succeeds, you should be able to execute the utility from your command line.</p>
<pre><code>$ cosmwasm-check --version
Contract checking 1.1.6
</code></pre>
<h2 id="verifying-the-installation"><a class="header" href="#verifying-the-installation">Verifying the installation</a></h2>
<p>To guarantee you are ready to build your smart contracts, you need to make sure you can build examples.
Checkout the <a href="https://github.com/CosmWasm/sylvia">sylvia</a> repository and run the testing command in
its folder:</p>
<pre><code>$ git clone git@github.com:CosmWasm/sylvia.git
$ cd ./sylvia
sylvia $ cargo test
</code></pre>
<p>You should see that everything in the repository gets compiled, and all tests pass. </p>
<p><code>sylvia</code> framework contains some examples of contracts. To find them go to <code>contracts</code> directory.
These contracts are maintained by CosmWasm creators, so contracts in there should follow good practices.</p>
<p>To verify the <code>cosmwasm-check</code> utility, first, you need to build a smart contract. Go to some contract
directory, for example, <code>contracts/cw1-whitelist</code>, and call <code>cargo wasm</code>:</p>
<pre><code>cw-plus $ cd contracts/cw1-whitelist
cw-plus/contracts/cw1-whitelist $ cargo wasm
</code></pre>
<p><code>wasm</code> is an alias for wasm = <code>&quot;build --release --target wasm32-unknown-unknown --lib&quot;</code>.
You should be able to find your output binary in the <code>target/wasm32-unknown-unknown/release/</code>
of the root repo directory - not in the contract directory itself! Now you can check if contract
validation passes:</p>
<pre><code>sylvia $ cosmwasm-check target/wasm32-unknown-unknown/release/cw1_whitelist.wasm
Available capabilities: {&quot;cosmwasm_1_1&quot;, &quot;iterator&quot;, &quot;stargate&quot;, &quot;staking&quot;}

target/wasm32-unknown-unknown/release/cw1_whitelist.wasm: pass

All contracts (1) passed checks!
</code></pre>
<h2 id="macro-expansion"><a class="header" href="#macro-expansion">Macro expansion</a></h2>
<p>Sylvia generates a lot of code for us which is not visible in code. To see what code is generated with it go to <code>contracts/cw1-whitelist/src/contract.rs</code>. In VSCode you can click on <code>#[contract]</code>, do <code>shift+p</code> and then type: <code>rust analyzer: Expand macro recursively</code>. This will open a window with fully expanded macro which you can browse. This is also possible f.e. in VIM depending on your configuration.
You can also use <code>cargo expand</code> tool from CLI for this.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start-with-wasmd"><a class="header" href="#quick-start-with-wasmd">Quick start with <code>wasmd</code></a></h1>
<p>This section is a quick guide on working with <code>wasmd</code> to test your smart contracts on the actual
blockchain. Note that this whole section is entirely optional - if you want to develop contracts
and test them with the UT environment, feel free to skip it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testnet-setup"><a class="header" href="#testnet-setup">Testnet setup</a></h1>
<p>To interact with a blockchain test net, the first thing to do is pick one. I suggest our generic
CosmWasm test net malaga-420. As <code>wasmd</code> is configured via environment variables, we will start
with creating a <code>malaga.env</code> file that sets them to proper values:</p>
<pre><code class="language-sh">export CHAIN_ID=&quot;malaga-420&quot;
export TESTNET_NAME=&quot;malaga-420&quot;
export FEE_DENOM=&quot;umlg&quot;
export STAKE_DENOM=&quot;uand&quot;
export BECH32_HRP=&quot;wasm&quot;
export WASMD_VERSION=&quot;v0.27.0&quot;
export CONFIG_DIR=&quot;.wasmd&quot;
export BINARY=&quot;wasmd&quot;

export GENESIS_URL=&quot;https://raw.githubusercontent.com/CosmWasm/testnets/master/malaga-420/config/genesis.json&quot;

export RPC=&quot;https://rpc.malaga-420.cosmwasm.com:443&quot;
export FAUCET=&quot;https://faucet.malaga-420.cosmwasm.com&quot;

export COSMOVISOR_VERSION=&quot;v0.42.10&quot;
export COSMOVISOR_HOME=/root/.wasmd
export COSMOVISOR_NAME=wasmd

export NODE=(--node $RPC)
export TXFLAG=($NODE --chain-id $CHAIN_ID --gas-prices 0.05umlg --gas auto --gas-adjustment 1.3)
</code></pre>
<p>If you are a fish user, this <code>malaga.fish</code> file may fit you better:</p>
<pre><code class="language-fish">set -x CHAIN_ID malaga-420
set -x TESTNET_NAME malaga-420
set -x FEE_DENOM umlg
set -x STAKE_DENOM uand
set -x BECH32_HRP wasm
set -x WASMD_VERSION v0.27.0
set -x CONFIG_DIR .wasmd
set -x BINARY wasmd

set -x GENESIS_URL https://raw.githubusercontent.com/CosmWasm/testnets/master/malaga-420/config/genesis.json

set -x RPC https://rpc.malaga-420.cosmwasm.com:443
set -x FAUCET https://faucet.malaga-420.cosmwasm.com

set -x COSMOVISOR_VERSION v0.42.10
set -x COSMOVISOR_HOME /root/.wasmd
set -x COSMOVISOR_NAME wasmd

set -x NODE $RPC
set -x TXFLAG --node $RPC --chain-id $CHAIN_ID --gas-prices 0.05umlg --gas-adjustment 1.3 --gas auto -b block
</code></pre>
<p>Now source the file to our environment (for fish use <code>malaga.fish</code> in place of <code>malaga.env</code>):</p>
<pre><code class="language-sh">$ source ./malaga.env
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="preparing-account"><a class="header" href="#preparing-account">Preparing account</a></h1>
<p>The first thing you need to interact with testnet is a valid account. Start with adding a new key to the <code>wasmd</code> configuration: </p>
<pre><code>$ wasmd keys add wallet
- name: wallet
  type: local
  address: wasm1wukxp2kldxae36rgjz28umqtq792twtxdfe6ux
  pubkey: '{&quot;@type&quot;:&quot;/cosmos.crypto.secp256k1.PubKey&quot;,&quot;key&quot;:&quot;A8pamTZH8x8+8UAFjndrvU4x7foJbCvcz78buyQ8q7+k&quot;}'
  mnemonic: &quot;&quot;
...
</code></pre>
<p>As a result of this command, you get information about just the prepared account. Two things are relevant here:</p>
<ul>
<li>address is your identity in the blockchain</li>
<li>mnemonic (omitted by myself in the example) is 12 words that allow you to recreate an account so you can use it, for
example, from a different machine</li>
</ul>
<p>For testing purposes, storing the mnemonic is probably never necessary, but it is critical information to keep safe in the real world.</p>
<p>Now, when you create an account, you have to initialize it with some tokens - you will need them to pay for any interaction with
blockchain - we call this the &quot;gas cost&quot; of an operation. Usually, you would need to buy those tokens somehow, but in testnets,
you can typically create as many tokens as you want on your accounts. To do so on malaga network, invoke:</p>
<pre><code>$ curl -X POST --header &quot;Content-Type: application/json&quot; \
  --data '{ &quot;denom&quot;: &quot;umlg&quot;, &quot;address&quot;: &quot;wasm1wukxp2kldxae36rgjz28umqtq792twtxdfe6ux&quot; }' \
  https://faucet.malaga-420.cosmwasm.com/credit
</code></pre>
<p>It is a simple HTTP POST request to the <code>https://faucet.malaga-420.cosmwasm.com/credit</code> endpoint. The data of this request is a JSON
containing the name of a token to mint and the address which should receive new tokens. Here we are minting <code>umlg</code> tokens, which are
tokens used to pay gas fees in the malaga testnet.</p>
<p>You can now verify your account tokens balance by invoking (substituting my address with yours):</p>
<pre><code>$ wasmd query bank balances wasm1wukxp2kldxae36rgjz28umqtq792twtxdfe6ux
balances:
- amount: &quot;100000000&quot;
  denom: umlg
pagination:
  next_key: null
  total: &quot;0&quot;
</code></pre>
<p>100M tokens should be plenty for playing around, and if you need more, you can always mint another batch.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interaction-with-testnet"><a class="header" href="#interaction-with-testnet">Interaction with testnet</a></h1>
<p>Blockchain interaction is performed using the
<a href="https://github.com/CosmWasm/wasmd">wasmd</a> command-line tool. To start working
with the testnet, we need to upload some smart contract code. For now, we would
use an example <code>cw4-group</code> from the <code>cw-plus</code> repository. Start with cloning
it:</p>
<pre><code>$ git clone git@github.com:CosmWasm/cw-plus.git
</code></pre>
<p>Now go to cloned repo and run Rust optimizer on it:</p>
<pre><code>$ docker run --rm -v &quot;$(pwd)&quot;:/code \
  --mount type=volume,source=&quot;$(basename &quot;$(pwd)&quot;)_cache&quot;,target=/code/target \
  --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \
  cosmwasm/workspace-optimizer:0.12.6
</code></pre>
<p>After a couple of minutes - it can take some for the first time - you should
have an <code>artifact</code> directory in your repo, and there should be a
<code>cw4-group.wasm</code> file being the contract we want to upload. To do so, run -
note that <code>wallet</code> is name of the key you created in the previous chapter:</p>
<pre><code>$ wasmd tx wasm store ./artifacts/cw4_group.wasm --from wallet $TXFLAG -y -b block

...
logs:
- events:
  - attributes:
    - key: action
      value: /cosmwasm.wasm.v1.MsgStoreCode
    - key: module
      value: wasm
    - key: sender
      value: wasm1wukxp2kldxae36rgjz28umqtq792twtxdfe6ux
    type: message
  - attributes:
    - key: code_id
      value: &quot;12&quot;
    type: store_code
...
</code></pre>
<p>As a result of execution, you should get a pretty long output with information
about what happened. Most of this is an ancient cipher (aka base64) with
execution metadata, but what we are looking for is the <code>logs</code> section. There
should be an event called <code>store_code,</code> with a single attribute <code>code_id</code> - its
<code>value</code> field is the code id of our uploaded contract - 12 in my case.</p>
<p>Now, when we have our code uploaded, we can go forward and instantiate a
contract to create its new instance:</p>
<pre><code>$ wasmd tx wasm instantiate 12 \
  '{ &quot;admin&quot;: &quot;wasm1wukxp2kldxae36rgjz28umqtq792twtxdfe6ux&quot;, &quot;members&quot;: [] }' \
  --from wallet --label &quot;Group&quot; --no-admin $TXFLAG -y

...
logs:
- events:
  - attributes:
    - key: _contract_address
      value: wasm18yn206ypuxay79gjqv6msvd9t2y49w4fz8q7fyenx5aggj0ua37q3h7kwz
    - key: code_id
      value: &quot;12&quot;
    type: instantiate
  - attributes:
    - key: action
      value: /cosmwasm.wasm.v1.MsgInstantiateContract
    - key: module
      value: wasm
    - key: sender
      value: wasm1wukxp2kldxae36rgjz28umqtq792twtxdfe6ux
    type: message
...

</code></pre>
<p>In this command, the <code>12</code> is the code id - the result of uploading the code.
After that, a JSON is an instantiation message - I will talk about this later.
Just think about it as a message requiring fields to create a new contract.
Every contract has its instantiation message format. For <code>cw4-group</code>, there are
two fields: <code>admin</code> is an address that would be eligible to execute messages on
this contract. It is crucial to set it to your address, as we will want to
learn how to execute contracts. <code>members</code> is an array of addresses that are
initial members of the group. We leave it empty for now, but you can put any
addresses you want there. Here, I put one hint about messages inline into the
command line, but I often put messages to be sent to the file and embed them
via <code>$(cat msg.json)</code>. It is fish syntax, but every shell provides a syntax for
this.</p>
<p>Then after the message, you need to add a couple of additional flags. The
<code>--from wallet</code> is the same as before - the name of the key you created
earlier. <code>--label &quot;Group&quot;</code> is just an arbitrary name for your contract. An
important one is a <code>--no-admin</code> flag - keep in mind that it is a different
&quot;admin&quot; that we set in the instantiation message. This flag is relevant only
for contract migrations, but we won't cover them right now, so leave this flag
as it is.</p>
<p>Now, look at the result of the execution. It is very similar to before - much
data about the execution process. And again, we need to take a closer look into
the <code>logs</code> section of the response. This time we are looking at an event with
type <code>instantiate</code>, and the <code>_contract_address</code> attribute - its value is newly
created contract address - <code>wasm1wukxp2kldxae36rgjz28umqtq792twtxdfe6ux</code> in an
example.</p>
<p>Now let's go forward with querying our contract:</p>
<pre><code>$ wasmd query wasm contract-state smart \
  wasm18yn206ypuxay79gjqv6msvd9t2y49w4fz8q7fyenx5aggj0ua37q3h7kwz \
  '{ &quot;list_members&quot;: {} }'

data:
  members: []
</code></pre>
<p>Remember to change the address (right after <code>smart</code>) with your contract
address. After that, there is another message - this time the query message -
which is sent to the contract. This query should return a list of group
members. And in fact, it does - response is a single <code>data</code> object with a
single field - empty members list. That was easy, now let's try the last thing:
the execution:</p>
<pre><code>$ wasmd tx wasm execute \
  wasm18yn206ypuxay79gjqv6msvd9t2y49w4fz8q7fyenx5aggj0ua37q3h7kwz \
  '{ &quot;update_members&quot;: { &quot;add&quot;: [{ &quot;addr&quot;: &quot;wasm1wukxp2kldxae36rgjz28umqtq792twtxdfe6ux&quot;, &quot;weight&quot;: 1 }], &quot;remove&quot;: [] } }' \
  --from wallet $TXFLAG
</code></pre>
<p>As you can see, execution is very similar to instantiation. The differences
are, that instantiation is called just once, and execution needs a contract
address. It is fair to say that instantiation is a particular case for first
execution, which returns the contract address. Just like before we can see that
we got some log output - you can analyze it to see that something probably
happened. But to ensure that there is an effect on blockchain, the best way
would be to query it once again:</p>
<pre><code>$ wasmd query wasm contract-state smart \
  wasm18yn206ypuxay79gjqv6msvd9t2y49w4fz8q7fyenx5aggj0ua37q3h7kwz \
  '{ &quot;list_members&quot;: {} }'

data:
  members:
  - addr: wasm1wukxp2kldxae36rgjz28umqtq792twtxdfe6ux
    weight: 1
</code></pre>
<p>For the time being, this is all you need to know about <code>wasmd</code> basics in order
to be able to play with your simple contracts. We would focus on testing them
locally, but if you want to check in real life, you have some basics now.
We will take a closer look at <code>wasmd</code> later when we would talk about the
architecture of the actor model defining communication between smart contracts.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-the-contract"><a class="header" href="#building-the-contract">Building the contract</a></h1>
<p>Now it is time to build our contract. We can use a traditional cargo build
pipeline for local testing purposes: <code>cargo build</code> for compiling it and <code>cargo test</code> for running all tests (which we don't have yet, but we will work on that
soon).</p>
<p>However, we need to create a wasm binary to upload the contract to blockchain.
We can do it by passing an additional argument to the build command:</p>
<pre><code>$ cargo build --target wasm32-unknown-unknown --release --lib
</code></pre>
<p>The <code>--target</code> argument tells cargo to perform cross-compilation for a given target instead of
building a native binary for an OS it is running on - in this case, <code>wasm32-unknown-unknown</code>,
which is a fancy name for Wasm target.</p>
<p>Contract would be properly created without <code>--lib</code> but later when we will add <code>query</code> it will be needed
so it is a good idea to add this argument from the beginning.</p>
<p>Additionally, I passed the <code>--release</code> argument to the command - it is not
required, but in most cases, debug information is not very useful while running
on-chain. It is crucial to reduce the uploaded binary size for gas cost
minimization. It is worth knowing that there is a <a href="https://github.com/CosmWasm/rust-optimizer">CosmWasm Rust
Optimizer</a> tool that takes care of
building even smaller binaries. For production, all the contracts should be
compiled using this tool, but for learning purposes it is not an essential
thing to do.</p>
<h2 id="aliasing-build-command"><a class="header" href="#aliasing-build-command">Aliasing build command</a></h2>
<p>Now I can see you are disappointed in building your contracts with some overcomplicated command
instead of simple <code>cargo build</code>. Hopefully, it is not the case. The common practice is to alias
the building command to make it as simple as building a native app.</p>
<p>Let's create the <code>.cargo/config</code> file in your contract project directory with the following content:</p>
<pre><code class="language-toml">[alias]
wasm = &quot;build --target wasm32-unknown-unknown --release --lib&quot;
wasm-debug = &quot;build --target wasm32-unknown-unknown --lib&quot;
</code></pre>
<p>Now, building your Wasm binary is as easy as executing <code>cargo wasm</code>. We also added the additional
<code>wasm-debug</code> command for rare cases when we want to build the wasm binary, including debug information.</p>
<h2 id="checking-contract-validity"><a class="header" href="#checking-contract-validity">Checking contract validity</a></h2>
<p>When the contract is built, the last step is to ensure it is a valid CosmWasm contract is to call
<code>cosmwasm-check</code> on it:</p>
<pre><code>$ cargo wasm
...
$ cosmwasm-check target/wasm32-unknown-unknown/release/contract.wasm
Available capabilities: {&quot;cosmwasm_1_1&quot;, &quot;iterator&quot;, &quot;staking&quot;, &quot;stargate&quot;}

target/wasm32-unknown-unknown/release/contract.wasm: pass

All contracts (1) passed checks!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics"><a class="header" href="#basics">Basics</a></h1>
<p>This chapter will go through creating basic smart contracts step by step.
I will explain the core ideas behind CosmWasm and the typical contract structure.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-rust-project"><a class="header" href="#create-a-rust-project">Create a Rust project</a></h1>
<p>As smart contracts are Rust library crates, we will start with creating one:</p>
<pre><code>$ cargo new --lib ./contract
</code></pre>
<p>You created a simple Rust library, but it is not yet ready to be a smart contract. The first thing
to do is to update the <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[package]
name = &quot;contract&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
cosmwasm-std = { version = &quot;1.1&quot;, features = [&quot;staking&quot;] }

</code></pre>
<p>As you can see, I added a <code>crate-type</code> field for the library section. Generating the
<a href="https://doc.rust-lang.org/reference/linkage.html"><code>cdylib</code></a> is
required to create a proper web assembly binary. The downside of this is that such a library cannot
be used as a dependency for other Rust crates - for now, it is not needed, but later we will show
how to approach reusing contracts as dependencies.</p>
<p>Additionally, we added one core dependency for smart contracts: the
<a href="https://docs.rs/cosmwasm-std/latest/cosmwasm_std/"><code>cosmwasm-std</code></a>. This crate is a
standard library for smart contracts. It provides essential utilities for communication with the
outside world, helper functions, and types. Every smart contract we will build will
use this dependency.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entry-points"><a class="header" href="#entry-points">Entry points</a></h1>
<p>Typical Rust application starts with the <code>fn main()</code> function called by the operating system.
Smart contracts are not significantly different. When the message is sent to the contract, a
function called &quot;entry point&quot; is called. Unlike native applications, which have only a single
<code>main</code> entry point, smart contracts have a couple corresponding to different message types:
<code>instantiate</code>, <code>execute</code>, <code>query</code>, <code>sudo</code>, <code>migrate</code> and more.</p>
<p>To start, we will go with three basic entry points:</p>
<ul>
<li><code>instantiate</code> is called once per smart contract lifetime - you can think about it as
a constructor or initializer of a contract.</li>
<li><code>execute</code> for handling messages which can modify contract state - they are used to
perform some actual actions.</li>
<li><code>query</code> for handling messages requesting some information from a contract; unlike <code>execute</code>,
they can never affect any contract state, and are used just like database queries.</li>
</ul>
<p>Go to your <code>src/lib.rs</code> file, and start with an <code>instantiate</code> entry point:</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::{entry_point, DepsMut, Empty, Env, MessageInfo, Response, StdResult};

#[entry_point]
pub fn instantiate(
    _deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    _msg: Empty,
) -&gt; StdResult&lt;Response&gt; {
    Ok(Response::new())
}
</code></pre>
<p>In fact, <code>instantiate</code> is the only entry point required for a smart contract to be valid. It is not
very useful in this form, but it is a start. Let's take a closer look at the entry point structure.</p>
<p>First, we import a couple of types for more consistent usage. Then we define our
entry point. The <code>instantiate</code> takes four arguments:</p>
<ul>
<li><a href="https://docs.rs/cosmwasm-std/1.1.0/cosmwasm_std/struct.DepsMut.html"><code>deps: DepsMut</code></a>
is an utility type for communicating with the outer world - it allows querying,
updating the contract state, querying other contracts state, and giving access to an <code>Api</code>
object with a couple of helper functions for dealing with CW addresses.</li>
<li><a href="https://docs.rs/cosmwasm-std/1.1.0/cosmwasm_std/struct.Env.html"><code>env: Env</code></a>
is an object representing the blockchains state when executing the message - the
chain height and id, current timestamp, and the called contract address.</li>
<li><a href="https://docs.rs/cosmwasm-std/1.1.0/cosmwasm_std/struct.MessageInfo.html"><code>info: MessageInfo</code></a>
contains metainformation about the message which triggered an execution -
an address that sends the message, and chain native tokens sent with the message.</li>
<li><a href="https://docs.rs/cosmwasm-std/1.1.0/cosmwasm_std/struct.Empty.html"><code>msg: Empty</code></a>
is the message triggering execution itself - for now, it is <code>Empty</code> type that
represents <code>{}</code> JSON, but the type of this argument can be anything that is deserializable,
and we will pass more complex types here in the future.</li>
</ul>
<p>If you are new to the blockchain, those arguments may not have much sense to you, but while
progressing through this book I will explain their usage one by one.</p>
<p>Notice an essential attribute decorating our entry point
<a href="https://docs.rs/cosmwasm-std/1.1.0/cosmwasm_std/attr.entry_point.html"><code>#[entry_point]</code></a>. Its
purpose is to wrap the whole entry point to the form Wasm runtime understands. The proper Wasm entry
points can use only basic types supported natively by Wasm specification, and Rust structures and
enums are not in this set. Working with such entry points would be rather overcomplicated, so
CosmWasm creators delivered the <code>entry_point</code> macro. It creates the raw Wasm entry point, calling
the decorated function internally and doing all the magic required to build our high-level Rust
arguments from arguments passed by Wasm runtime.</p>
<p>The next thing to look at is the return type. I used
<a href="https://docs.rs/cosmwasm-std/1.1.0/cosmwasm_std/type.StdResult.html"><code>StdResult&lt;Response&gt;</code></a> for
this simple example, which is an alias for <code>Result&lt;Response, StdError&gt;</code>. The return entry point
type would always be a <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> type, with
some error type implementing <a href="https://doc.rust-lang.org/std/string/trait.ToString.html"><code>ToString</code></a>
trait and a well-defined type for success case. For most entry points, an &quot;Ok&quot; case would be the
<a href="https://docs.rs/cosmwasm-std/1.1.0/cosmwasm_std/struct.Response.html"><code>Response</code></a> type that allows
fitting the contract into our actor model, which we will discuss very soon.</p>
<p>The body of the entry point is as simple as it could be - it always succeeds with a trivial empty
response.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-first-messages"><a class="header" href="#generating-first-messages">Generating first messages</a></h1>
<p>We have already created a simple contract reacting to an <code>Empty</code> message on instantiate.
Unfortunately, it is not very useful. Let's make it reactive.</p>
<h2 id="updating-dependencies"><a class="header" href="#updating-dependencies">Updating dependencies</a></h2>
<p>First, we need to add <a href="https://crates.io/crates/sylvia"><code>sylvia</code></a> and some other crates to our project.</p>
<pre><code class="language-toml">[package]
name = &quot;contract&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
cosmwasm-std = { version = &quot;1.1&quot;, features = [&quot;staking&quot;] }
cosmwasm-schema = &quot;1.1.6&quot;
serde = { version = &quot;1.0.147&quot;, features = [&quot;derive&quot;] }
sylvia = &quot;0.2.1&quot;
schemars = &quot;0.8.11&quot;
</code></pre>
<p>We had to add also some more dependencies required for generated by <code>sylvia</code> code to compile:</p>
<ul>
<li><a href="https://docs.rs/cosmwasm-schema/latest/cosmwasm_schema/"><code>cosmwasm-schema</code></a> - we will later rely
on this dependency to generate the API schema of our contract.</li>
<li><a href="https://docs.rs/serde/latest/serde/"><code>serde</code></a> - very important framework for serializing and
deserializing Rust data structures. It is crucial as serialization is required for messages to be
sent from and to the <code>contract</code>.</li>
<li><a href="https://docs.rs/schemars/latest/schemars/"><code>schemars</code></a> - it will also be required later when
dealing with generating the schema of our API.</li>
</ul>
<h2 id="creating-an-instantiation-message"><a class="header" href="#creating-an-instantiation-message">Creating an instantiation message</a></h2>
<p>For, this step we will create a new file:</p>
<ul>
<li><code>src/contract.rs</code> - here, we will define our messages and behavior of the contract upon receiving
them</li>
</ul>
<p>Add this module to <code>src/lib.rs</code>. You want it to be public, as users might want to get access to
types stored inside your contract.</p>
<pre><code class="language-rust noplayground">pub mod contract;

use cosmwasm_std::{entry_point, DepsMut, Empty, Env, MessageInfo, Response, StdResult};

#[entry_point]
pub fn instantiate(
    _deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    _msg: Empty,
) -&gt; StdResult&lt;Response&gt; {
    Ok(Response::new())
}
</code></pre>
<p>Now let's create an <code>instantiate</code> method for our contract. In <code>src/contract.rs</code></p>
<pre><code class="language-rust noplayground">use cosmwasm_std::{DepsMut, Env, MessageInfo, Response, StdResult};
use schemars;
use sylvia::contract;

pub struct AdminContract;

pub type ContractError = cosmwasm_std::StdError;

#[contract]
impl AdminContract {
    #[msg(instantiate)]
    pub fn instantiate(&amp;self, _ctx: (DepsMut, Env, MessageInfo)) -&gt; StdResult&lt;Response&gt; {
        Ok(Response::new())
    }
}
</code></pre>
<p>So what is going on here? First, we define the Admin struct. It is empty right now but later when we
will learn about states and their fields will be used to store them.
We introduce the alias <code>ContractError</code>, required by <code>sylvia</code>. Later we will create our custom
<code>ContractError</code>, but for now, it is enough to just alias the
<a href="https://docs.rs/cosmwasm-std/latest/cosmwasm_std/enum.StdError.html"><code>cosmwasm_std::StdError</code></a>.
Notice it is marked as <code>pub</code> as we want it to be accessible in other modules.
Next, we create an <code>impl</code> block for <code>Admin</code> and invoke the <code>contract </code>attribute macro from <code>sylvia</code>.
It will generate a lot of boilerplate for us regarding messages generation and their dispatch. It
will also make sure that none of the messages overlap and will catch it on compile time.
Then there is a method instantiate which currently doesn't do much.
What's important here is the <code>#[msg(instantiate)]</code>. <code>contract</code> macro will parse through the method
and, based on its structure, generate InstantiateMsg with parameters equal to ones declared in
<code>instantiate</code> method past <code>_ctx</code>. F.e., this will generate among others</p>
<pre><code class="language-rust noplayground">impl AdminContract {
    pub fn instantiate(
        &amp;self,
        _ctx: (DepsMut, Env, MessageInfo),
    ) -&gt; StdResult&lt;Response&gt; {
        Ok(Response::new())
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(
    sylvia::serde::Serialize,
    sylvia::serde::Deserialize,
    Clone,
    Debug,
    PartialEq,
    sylvia::schemars::JsonSchema,
)]
#[serde(rename_all = &quot;snake_case&quot;)]
pub struct InstantiateMsg {}

impl InstantiateMsg {
    pub fn dispatch(
        self,
        contract: &amp;AdminContract,
        ctx: (
            cosmwasm_std::DepsMut,
            cosmwasm_std::Env,
            cosmwasm_std::MessageInfo,
        ),
    ) -&gt; StdResult&lt;Response&gt; {
        let Self {} = self;
        contract.instantiate(ctx.into()).map_err(Into::into)
    }
}
</code></pre>
<p>Let's focus on instantiate right now. As you can see, struct InstantiateMsg with all needed derives
is being generated for you. Most important are
<a href="https://docs.rs/serde/latest/serde/trait.Serialize.html"><code>Serialize</code></a>
and <a href="https://docs.rs/serde/latest/serde/trait.Deserialize.html"><code>Deserialize</code></a>
There is also <code>#[serde(rename_all = &quot;snake_case&quot;)]</code>, which is not important for now.</p>
<p>Sylvia also generates a <code>dispatch</code> method for every msg linking it with user specified-behavior. One
of its arguments is <code>AdminContract</code>, on which the message should be dispatched. Let's create the
<code>new</code> method:</p>
<p><code>src/contract.rs</code></p>
<pre><code class="language-rust noplayground">use cosmwasm_std::{DepsMut, Env, MessageInfo, Response, StdResult};
use schemars;
use sylvia::contract;

pub struct AdminContract;

pub type ContractError = cosmwasm_std::StdError;

#[contract]
impl AdminContract {
    #[msg(instantiate)]
    pub fn instantiate(&amp;self, _ctx: (DepsMut, Env, MessageInfo)) -&gt; StdResult&lt;Response&gt; {
        Ok(Response::new())
    }
}
</code></pre>
<p>Great, now we can modify the <code>src/lib.rs</code></p>
<pre><code class="language-rust noplayground">pub mod contract;

use cosmwasm_std::{entry_point, DepsMut, Empty, Env, MessageInfo, Response, StdResult};

use crate::contract::{InstantiateMsg, AdminContract};

#[entry_point]
pub fn instantiate(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: InstantiateMsg,
) -&gt; StdResult&lt;Response&gt; {
    msg.dispatch(&amp;AdminContract, (deps, env, info))
}
</code></pre>
<p><code>Empty</code> is now changed to <code>InstantiateMsg</code> generated by <code>sylvia</code>.
We dispatch the message, and it will trigger <code>instatiation</code> method.
For now, it is just returning an empty Response, but let's change it in the following chapters,
where we will introduce states and queries.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contract-state"><a class="header" href="#contract-state">Contract state</a></h1>
<p>We can instantiate our contract, but it doesn't do anything afterward.
Let's make it more complex. In this chapter we will introduce the contracts state.</p>
<h2 id="adding-contract-state"><a class="header" href="#adding-contract-state">Adding contract state</a></h2>
<p>We will initialize the on contract instantiation. The state
will contain a list of admins who would be eligible to execute messages in the future.</p>
<p>The first thing to do is to update <code>Cargo.toml</code> with yet another dependency - the
<a href="https://crates.io/crates/cw-storage-plus"><code>storage-plus</code></a> crate with high-level bindings for
CosmWasm smart contracts state management:</p>
<pre><code class="language-toml">[package]
name = &quot;contract&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
cosmwasm-std = { version = &quot;1.1&quot;, features = [&quot;staking&quot;] }
cosmwasm-schema = &quot;1.1.6&quot;
serde = { version = &quot;1.0.147&quot;, features = [&quot;derive&quot;] }
sylvia = &quot;0.2.1&quot;
schemars = &quot;0.8.11&quot;
cw-storage-plus = &quot;1.0&quot;
</code></pre>
<p>Now add the state as a field in your contract and instantiate it in the <code>new</code> method.</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::{Addr, DepsMut, Empty, Env, MessageInfo, Response, StdResult};
use cw_storage_plus::Map;
use schemars;
use sylvia::contract;

pub struct AdminContract&lt;'a&gt; {
    pub(crate) admins: Map&lt;'a, &amp;'a Addr, Empty&gt;,
}

#[contract]
impl AdminContract&lt;'_&gt; {
    pub const fn new() -&gt; Self {
        Self {
            admins: Map::new(&quot;admins&quot;),
        }
    }

    #[msg(instantiate)]
    pub fn instantiate(
        &amp;self,
        _ctx: (DepsMut, Env, MessageInfo),
    ) -&gt; StdResult&lt;Response&gt; {
        Ok(Response::new())
    }
}
</code></pre>
<p>New types:</p>
<ul>
<li>
<p><a href="https://docs.rs/cw-storage-plus/0.16.0/cw_storage_plus/struct.Map.html"><code>Map&lt;_, _&gt;</code></a></p>
</li>
<li>
<p><a href="https://docs.rs/cosmwasm-std/0.16.0/cosmwasm_std/struct.Addr.html"><code>Addr</code></a> - representation of
actual address on a blockchain.</p>
</li>
<li>
<p><a href="https://docs.rs/cosmwasm-std/0.16.0/cosmwasm_std/struct.Empty.html"><code>Empty</code></a> - an empty struct
that serves as a placeholder.</p>
</li>
</ul>
<p>We declared state <code>admins</code> as immutable <code>Map&lt;'a, &amp;'a Addr, Empty&gt;</code>.
It might seem weird that we created <code>Map</code> with an <code>Empty</code> value containing no information. Still,
our alternative would be to store it as <code>Vec&lt;Addr&gt;</code>, forcing us to load whole the <code>Vec</code> to
alternate it or read a single element which would be a costly operation.
Because of that, it is better to declare it as a <code>Map</code>.</p>
<p>But why isn't it mutable? How will we modify the elements?</p>
<p>The answer is tricky - this immutable is not keeping the state itself. The state is stored in the
blockchain, and we can access it via the <code>deps</code> argument passed to entry points. The storage-plus
constants are just accessor utilities helping us access this state in a structured way.</p>
<p>In CosmWasm, the blockchain state is just massive key-value storage. The keys are prefixed with
metainformation pointing to the contract which owns them (so no other contract can alter them),
but even after removing the prefixes, the single contract state is a smaller key-value pair.</p>
<p><code>storage-plus</code> handles more complex state structures by additionally prefixing item keys
intelligently. The key to the <code>Map</code> doesn't matter to us - it would be figured out to be unique
based on a unique string passed to the
<a href="https://docs.rs/cw-storage-plus/0.13.4/cw_storage_plus/struct.Item.html#method.new"><code>new</code></a> method.</p>
<p>Last new thing. We crated the <code>new</code> method for the <code>AdminContract</code> to hide the instantiation of
the fields.</p>
<h2 id="initializing-the-state"><a class="header" href="#initializing-the-state">Initializing the state</a></h2>
<p>Now that the state field has been added we can improve our instantiate. We will make it possible for
a user to add new admins at contract instantiation.</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::{Addr, DepsMut, Empty, Env, MessageInfo, Response};
use cw_storage_plus::Map;
use schemars;
use sylvia::contract;
<span class="boring">
</span><span class="boring">pub struct AdminContract&lt;'a&gt; {
</span><span class="boring">   pub(crate) admins: Map&lt;'a, &amp;'a Addr, Empty&gt;,
</span><span class="boring">}
</span>
#[contract]
impl AdminContract&lt;'_&gt; {
<span class="boring">   pub const fn new() -&gt; Self {
</span><span class="boring">       Self {
</span><span class="boring">           admins: Map::new(&quot;admins&quot;),
</span><span class="boring">       }
</span><span class="boring">   }
</span>    ...

    #[msg(instantiate)]
    pub fn instantiate(
        &amp;self,
        ctx: (DepsMut, Env, MessageInfo),
        admins: Vec&lt;String&gt;,
    ) -&gt; StdResult&lt;Response&gt; {
        let (deps, _, _) = ctx;

        for admin in admins {
            let admin = deps.api.addr_validate(&amp;admin)?;
            self.admins.save(deps.storage, &amp;admin, &amp;Empty {})?;
        }

        Ok(Response::new())
    }
}
</code></pre>
<p>Voila, that's all that is needed to update the state! With this change when we expand <code>contract</code>
macro we should see:</p>
<pre><code class="language-rust noplayground">#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(
    sylvia::serde::Serialize,
    sylvia::serde::Deserialize,
    Clone,
    Debug,
    PartialEq,
    sylvia::schemars::JsonSchema,
)]
#[serde(rename_all = &quot;snake_case&quot;)]
pub struct InstantiateMsg {
    pub admins: Vec&lt;String&gt;,
}
impl InstantiateMsg {
    pub fn dispatch(
        self,
        contract: &amp;AdminContract&lt;'_&gt;,
        ctx: (
            cosmwasm_std::DepsMut,
            cosmwasm_std::Env,
            cosmwasm_std::MessageInfo,
        ),
    ) -&gt; StdResult&lt;Response&gt; {
        let Self { admins } = self;
        contract.instantiate(ctx.into(), admins).map_err(Into::into)
    }
}
</code></pre>
<p>As you can see, admins was set as a field of <code>InstantiateMsg</code>, and in <code>dispatch</code>, it's forwarded to
instantiate implemented in our contract. There <code>vector</code> of strings is being transformed into a
<code>vector</code> of <code>Addr</code>. We cannot take addresses as a message argument because only some strings are
valid addresses. It might be confusing once we are working on tests. Any string could be used
in the place of address.</p>
<p>Let me explain. Every string can be technically considered an address. However, not every string is
an actual existing blockchain address. When we keep anything of type <code>Addr</code> in the contract, we
assume it is a proper address in the blockchain. That is why the
<a href="https://docs.rs/cosmwasm-std/1.1.0/cosmwasm_std/trait.Api.html#tymethod.addr_validate"><code>addr_validate</code></a>
function exits - to check this precondition.</p>
<p>Having data to store, we use the
<a href="https://docs.rs/cw-storage-plus/0.16.0/cw_storage_plus/struct.Map.html#method.save"><code>save</code></a>
function to write it into the contract state. Note that the first argument of <code>save</code> is
<a href="https://docs.rs/cosmwasm-std/1.1.0/cosmwasm_std/trait.Storage.html"><code>&amp;mut Storage</code></a>, which is
actual blockchain storage. As emphasized, the <code>Map</code> object stores nothing and is an accessor.
It determines how to store the data in the storage given to it. The second argument is the
serializable data to be stored, and the last one is the value which in our case is <code>Empty</code>.</p>
<p>With the state added to our contract, let's also update the entry_point. Go to <code>src/lib.rs</code>:</p>
<pre><code class="language-rust noplayground">pub mod contract;

use cosmwasm_std::{entry_point, DepsMut, Empty, Env, MessageInfo, Response, StdResult};

use crate::contract::{InstantiateMsg, AdminContract};

const CONTRACT: AdminContract = AdminContract::new();

#[entry_point]
pub fn instantiate(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: InstantiateMsg,
) -&gt; StdResult&lt;Response&gt; {
    msg.dispatch(&amp;CONTRACT, (deps, env, info))
}
</code></pre>
<p>Instead of passing the <code>&amp;AdminContract</code> to the <code>dispatch</code> method, we first create the inner value
<code>CONTRACT</code> by calling <code>AdminContract::new()</code>.</p>
<p>Nice, we now have the state initialized on our contract, but we can't validate if the data is
stored correctly. Let's change it in the next chapter, in which we will introduce <code>query</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-query"><a class="header" href="#creating-a-query">Creating a query</a></h1>
<p>We can now initialize our contract and store some data in it. Let's write <code>query</code> to read it's
content. We have already created a simple contract reacting to an empty instantiate message.
Unfortunately, it is not very useful. Let's make it more reactive.</p>
<h2 id="declaring-query-response"><a class="header" href="#declaring-query-response">Declaring query response</a></h2>
<p>Let's create a new file, <code>src/responses.rs</code>, containing responses to all the queries in our contract.</p>
<pre><code class="language-rust noplayground">use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Clone, PartialEq, Eq, schemars::JsonSchema, Debug, Default)]
pub struct AdminListResp {
    pub admins: Vec&lt;String&gt;,
}
</code></pre>
<p>We have here similar derives like in the case of <code>InstantiateMsg</code>.
The most important ones are <code>Serialize</code> and <code>Deserialize</code> as we always want to return something
serializable.</p>
<p><code>src/responses.rs</code> is not part of our project, so let's change it. Go to <code>src/lib.rs</code> and add this module:</p>
<pre><code class="language-rust noplayground">pub mod contract;
pub mod responses;

use cosmwasm_std::{entry_point, DepsMut, Empty, Env, MessageInfo, Response, StdResult};

use crate::contract::{InstantiateMsg, AdminContract};

const CONTRACT: AdminContract = AdminContract::new();

#[entry_point]
pub fn instantiate(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: InstantiateMsg,
) -&gt; StdResult&lt;Response&gt; {
    msg.dispatch(&amp;CONTRACT, (deps, env, info))
}
</code></pre>
<p>Now that we have a response created, go to your <code>src/contract.rs</code> file and declare a new <code>query</code>.</p>
<pre><code class="language-rust noplayground">use crate::responses::AdminListResp;
use cosmwasm_std::{Addr, Deps, DepsMut, Empty, Env, MessageInfo, Order, Response, StdResult};
use cw_storage_plus::Map;
use schemars;
use sylvia::contract;

<span class="boring">pub struct AdminContract&lt;'a&gt; {
</span><span class="boring">   pub(crate) admins: Map&lt;'static, &amp;'a Addr, Empty&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>#[contract]
impl AdminContract&lt;'_&gt; {
    ...

    #[msg(query)]
    pub fn admin_list(&amp;self, ctx: (Deps, Env)) -&gt; StdResult&lt;AdminListResp&gt; {
        let (deps, _) = ctx;

        let admins: Result&lt;_, _&gt; = self
            .admins
            .keys(deps.storage, None, None, Order::Ascending)
            .map(|addr| addr.map(String::from))
            .collect();

        Ok(AdminListResp { admins: admins? })
    }
}

</code></pre>
<p>With this done, we can expand our <code>contract</code> macro and see that QueryMsg is generated.</p>
<pre><code class="language-rust noplayground">#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(
    sylvia::serde::Serialize,
    sylvia::serde::Deserialize,
    Clone,
    Debug,
    PartialEq,
    sylvia::schemars::JsonSchema,
    cosmwasm_schema::QueryResponses,
)]
#[serde(rename_all = &quot;snake_case&quot;)]
pub enum QueryMsg {
    #[returns(AdminListResp)]
    AdminList {},
}
impl QueryMsg {
    pub fn dispatch(
        self,
        contract: &amp;AdminContract,
        ctx: (cosmwasm_std::Deps, cosmwasm_std::Env),
    ) -&gt; std::result::Result&lt;sylvia::cw_std::Binary, ContractError&gt; {
        use QueryMsg::*;
        match self {
            AdminList {} =&gt; {
                cosmwasm_std::to_binary(&amp;contract.admin_list(ctx.into())?).map_err(Into::into)
            }
        }
    }
}
</code></pre>
<p>We will ignore <code>#[returns(_)]</code> and <code>cosmwasm_schema::QueryResponses</code> as they will be described later
when we will talk about generating schema.</p>
<p><code>QueryMsg</code> is an enum that will contain every <code>query</code> declared in your expanded impl. Thanks to
that you can focus solely on defining the behavior of the contract on receiving a message, and you
can leave it to <code>sylvia</code> to generate the messages and the <code>dispatch</code>.</p>
<p>Note that our enum has no type assigned to the only <code>AdminList</code> variant. Typically
in Rust, we create such variants without additional <code>{}</code> after the variant name. Here the
curly braces have a purpose. Without, them the variant would serialize to just a string
type - so instead of <code>{ &quot;admin_list&quot;: {} }</code>, the JSON representation of this variant would be
<code>&quot;admin_list&quot;</code>.</p>
<p>Instead of returning the <code>Response</code> type on the success
case, we return an arbitrary serializable object. It's because queries are not using a typical
actor model message flow - they cannot trigger any actions nor communicate with other contracts in
ways different than querying them (which is handled by the <code>deps</code> argument). The query always
returns plain data, which should be presented directly to the querier.
Sylvia does that by returning encoded response as
<a href="https://docs.rs/cosmwasm-std/1.1.0/cosmwasm_std/struct.Binary.html"><code>Binary</code></a> by calling
<a href="https://docs.rs/cosmwasm-std/1.1.0/cosmwasm_std/fn.to_binary.html"><code>to_binary</code></a> function in dispatch.</p>
<p>In the case of <code>query</code> <code>ctx</code> is tuple of
<a href="https://docs.rs/cosmwasm-std/1.1.0/cosmwasm_std/struct.Deps.html"><code>Deps</code></a> and <code>Env</code>.
We use <code>Deps</code> instead of <code>DepsMut</code> as we did in the case of <code>instantiate</code> because the query can
never alter internal state of the smart contracts . It can only read the state. It comes with some
consequences - for example, it is impossible to implement caching for future queries (as it would
require some data cache to write to).</p>
<p>The other difference is the lack of the <code>info</code> argument. The reason here is that the entry point which
performs actions (like instantiation or execution) can differ in how an action is performed based on the
message metadata - for example, they can limit who can perform an action (and do so by checking the
message <code>sender</code>). It is not a case for queries. Queries are purely to return some
transformed contract state. It can be calculated based on chain metadata (so the state can
&quot;automatically&quot; change after some time) but not on message info.</p>
<p>Now that QueryMsg is created, let's allow users to call it by defining the entry point for
query in <code>src/lib.rs</code>.</p>
<pre><code class="language-rust noplayground">pub mod contract;
pub mod responses;

use contract::{ContractError, ContractQueryMsg};
use cosmwasm_std::{entry_point, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};

use crate::contract::{AdminContract, InstantiateMsg};

const CONTRACT: AdminContract = AdminContract::new();

#[entry_point]
pub fn instantiate(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: InstantiateMsg,
) -&gt; StdResult&lt;Response&gt; {
    msg.dispatch(&amp;CONTRACT, (deps, env, info))
}

#[entry_point]
pub fn query(deps: Deps, env: Env, msg: ContractQueryMsg) -&gt; Result&lt;Binary, ContractError&gt; {
    msg.dispatch(&amp;CONTRACT, (deps, env))
}
</code></pre>
<p>There is one more new thing here. We were still talking about <code>QueryMsg</code>, but now we use
<code>ContractQueryMsg</code> out of nowhere. Let me explain. <code>Sylvia</code> framework allows us to define
<a href="https://docs.rs/sylvia/latest/sylvia/attr.interface.html"><code>interfaces</code></a>. Users can create
interfaces with specific functionalities and then implement them on contract. <code>ContractQueryMsg</code> is
wrapper over <code>QueryMsg</code>s from a contract and it's interfaces which <code>dispatch</code> will call proper
implementation. We will learn about <code>Interfaces</code> further in the book.</p>
<p>Now, when we have the contract ready to do something, let's go and test it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-a-query"><a class="header" href="#testing-a-query">Testing a query</a></h1>
<p>Last time we created a new query. Now it is time to test it out. We will start with the basics -
the unit test. This approach is simple and doesn't require much knowledge besides Rust. Go to the
<code>src/contract.rs</code> and add a test at the bottom of the file:</p>
<pre><code class="language-rust noplayground"><span class="boring">use crate::responses::AdminListResp;
</span><span class="boring">use cosmwasm_std::{Addr, Deps, DepsMut, Empty, Env, MessageInfo, Order, Response, StdResult};
</span><span class="boring">use cw_storage_plus::Map;
</span><span class="boring">use schemars;
</span><span class="boring">use sylvia::contract;
</span><span class="boring">
</span><span class="boring">pub struct AdminContract&lt;'a&gt; {
</span><span class="boring">   pub(crate) admins: Map&lt;'a, &amp;'a Addr, Empty&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[contract]
</span><span class="boring">impl AdminContract&lt;'_&gt; {
</span><span class="boring">   pub const fn new() -&gt; Self {
</span><span class="boring">       Self {
</span><span class="boring">           admins: Map::new(&quot;admins&quot;),
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[msg(instantiate)]
</span><span class="boring">   pub fn instantiate(
</span><span class="boring">       &amp;self,
</span><span class="boring">       ctx: (DepsMut, Env, MessageInfo),
</span><span class="boring">       admins: Vec&lt;String&gt;,
</span><span class="boring">   ) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">       let (deps, _, _) = ctx;
</span><span class="boring">
</span><span class="boring">       for admin in admins {
</span><span class="boring">           let admin = deps.api.addr_validate(&amp;admin)?;
</span><span class="boring">           self.admins.save(deps.storage, &amp;admin, &amp;Empty {})?;
</span><span class="boring">       }
</span><span class="boring">
</span><span class="boring">       Ok(Response::new())
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[msg(query)]
</span><span class="boring">   pub fn admin_list(&amp;self, ctx: (Deps, Env)) -&gt; StdResult&lt;AdminListResp&gt; {
</span><span class="boring">       let (deps, _) = ctx;
</span><span class="boring">
</span><span class="boring">       let admins: Result&lt;_, _&gt; = self
</span><span class="boring">           .admins
</span><span class="boring">           .keys(deps.storage, None, None, Order::Ascending)
</span><span class="boring">           .map(|addr| addr.map(String::from))
</span><span class="boring">           .collect();
</span><span class="boring">
</span><span class="boring">       Ok(AdminListResp { admins: admins? })
</span><span class="boring">   }
</span><span class="boring">}
</span>
#[cfg(test)]
mod tests {
    use crate::entry_points::{instantiate, query};
    use cosmwasm_std::from_binary;
    use cosmwasm_std::testing::{mock_dependencies, mock_env, mock_info};

    use super::*;

    #[test]
    fn admin_list_query() {
        let mut deps = mock_dependencies();
        let env = mock_env();

        instantiate(
            deps.as_mut(),
            env.clone(),
            mock_info(&quot;sender&quot;, &amp;[]),
            InstantiateMsg {
                admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
            },
        )
        .unwrap();

        let msg = QueryMsg::AdminList {};
        let resp = query(deps.as_ref(), env, ContractQueryMsg::AdminContract(msg)).unwrap();
        let resp: AdminListResp = from_binary(&amp;resp).unwrap();
        assert_eq!(
            resp,
            AdminListResp {
                admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
            }
        );
    }
}
</code></pre>
<p>We have a simple flow here:</p>
<ul>
<li>we instantiate contract with admins [&quot;admin1&quot;, &quot;admin2&quot;],</li>
<li>we query the contract to see if both of them will be returned</li>
</ul>
<p>Our <code>instantiate</code>, and <code>query</code> require deps and env as parameters. We will mock them with
<a href="https://docs.rs/cosmwasm-std/1.1.0/cosmwasm_std/testing/fn.mock_dependencies.html"><code>mock_dependencies</code></a>
and <a href="https://docs.rs/cosmwasm-std/1.1.0/cosmwasm_std/testing/fn.mock_env.html"><code>mock_env</code></a> from
<code>comswasm-std</code>.</p>
<p>You may notice the dependencies mock if of a type
<a href="https://docs.rs/cosmwasm-std/1.1.0/cosmwasm_std/struct.OwnedDeps.html"><code>OwnedDeps</code></a> instead
of <code>Deps</code>, which we need here - this is why the
<a href="https://docs.rs/cosmwasm-std/1.1.0/cosmwasm_std/struct.OwnedDeps.html#method.as_ref"><code>as_ref</code></a>
function is called on it. If we needed a <code>DepsMut</code> object, we would use
<a href="https://docs.rs/cosmwasm-std/1.1.0/cosmwasm_std/struct.OwnedDeps.html#method.as_mut"><code>as_mut</code></a>
instead.</p>
<p>I extracted the <code>deps</code> and <code>env</code> to variables
and passed them to calls. The idea is that those represent some blockchain persistent state,
and we don't want to create them for every call. We want any changes to the contract state occurring
in <code>instantiate</code> to be visible in the <code>query</code>. Also, we want to control how the environment differs
in the query and instantiation.</p>
<p>The <code>info</code> argument is another story. The message info is unique for each message sent. To create
the <code>info</code> mock, we must pass two arguments to the
<a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/testing/fn.mock_info.html"><code>mock_info</code></a> function.</p>
<p>First is the address performing a call. It may look strange to pass <code>sender</code> as an address instead
of some mysterious <code>wasm</code> followed by hash, but it is a valid address. For testing purposes, such
addresses are typically better, as they are way more verbose in case of failing tests.</p>
<p>The second argument is the <code>funds</code> that are sent with the message. For now, we leave it as an empty
slice, as I don't want to talk about token transfers yet - we will cover it later.</p>
<p>So now it is more like a real-case scenario. I see just one problem. Nothing connects the <code>instantiate</code>
call to the corresponding <code>query</code>. It seems that we assume there is some global contract. But if we
would like to have two contracts instantiated differently in a single test case, it
would become a mess. If only some tool could abstract this for us, wouldn't it be nice?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introducing-multitest"><a class="header" href="#introducing-multitest">Introducing multitest</a></h1>
<p>Let me introduce the <a href="https://crates.io/crates/cw-multi-test"><code>multitest</code></a> -
library for creating tests for smart contracts in Rust.</p>
<p>The core idea of <code>multitest</code> is abstracting an entity of contract and
simulating the blockchain environment for testing purposes. The purpose of this
is to be able to test communication between smart contracts. It does its job
well, but it is also an excellent tool for testing single-contract scenarios.</p>
<h2 id="update-dependencies"><a class="header" href="#update-dependencies">Update dependencies</a></h2>
<p>First, we need to add a <a href="https://docs.rs/cw-multi-test/latest/cw_multi_test/"><code>cw-multi-test</code></a> to
our <code>Cargo.toml</code>. We will also add <a href="https://docs.rs/anyhow/1.0.66/anyhow/"><code>anyhow</code></a>. We will use it
to bail on calls to unimplemented entry points like <code>reply</code>, <code>migrate</code>, and <code>sudo</code>.</p>
<pre><code class="language-toml">[package]
name = &quot;contract&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[lib]
crate-type = [&quot;cdylib&quot;]

[features]
library = []

[dependencies]
cosmwasm-std = { version = &quot;1.1&quot;, features = [&quot;staking&quot;] }
cosmwasm-schema = &quot;1.1.6&quot;
serde = { version = &quot;1.0.147&quot;, features = [&quot;derive&quot;] }
sylvia = &quot;0.2.1&quot;
schemars = &quot;0.8.11&quot;
cw-storage-plus = &quot;0.16.0&quot;

[dev-dependencies]
anyhow = &quot;1&quot;
cw-multi-test = &quot;0.16&quot;
</code></pre>
<p>I added a new
<a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#development-dependencies"><code>[dev-dependencies]</code></a>
section with dependencies not used by the final binary
but which may be used by tools around the development process - for example, tests.</p>
<h2 id="creating-a-module-for-tests"><a class="header" href="#creating-a-module-for-tests">Creating a module for tests</a></h2>
<p>Now we will create a new module, <code>multitest</code>. Let's first add it to the <code>src/lib.rs</code></p>
<pre><code class="language-rust noplayground">pub mod contract;
pub mod responses;

#[cfg(test)]
mod multitest;

<span class="boring">use cosmwasm_std::{entry_point, Binary, Deps, DepsMut, Env, MessageInfo, Response};
</span><span class="boring">
</span><span class="boring">use crate::contract::{AdminContract, ContractQueryMsg, InstantiateMsg};
</span><span class="boring">
</span><span class="boring">const CONTRACT: AdminContract = AdminContract::new();
</span><span class="boring">
</span><span class="boring">#[entry_point]
</span><span class="boring">pub fn instantiate(
</span><span class="boring">   deps: DepsMut,
</span><span class="boring">   env: Env,
</span><span class="boring">   info: MessageInfo,
</span><span class="boring">   msg: InstantiateMsg,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">   msg.dispatch(&amp;CONTRACT, (deps, env, info))
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[entry_point]
</span><span class="boring">pub fn query(deps: Deps, env: Env, msg: ContractQueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">   msg.dispatch(&amp;CONTRACT, (deps, env))
</span><span class="boring">}
</span></code></pre>
<p>As this module is purely for testing purpose, we prefix it with
<a href="https://doc.rust-lang.org/book/ch11-03-test-organization.html#the-tests-module-and-cfgtest"><code>#[cfg(test)]</code></a>.</p>
<p>Now create <code>src/multitest.rs</code>.</p>
<pre><code class="language-rust noplayground">use anyhow::{bail, Result as AnyResult};
use cosmwasm_std::{from_slice, Empty};
use cw_multi_test::Contract;

use crate::contract::{AdminContract, ContractExecMsg, ContractQueryMsg, InstantiateMsg};

mod proxy;
mod tests;

impl Contract&lt;Empty&gt; for AdminContract&lt;'_&gt; {
    fn execute(
        &amp;self,
        deps: cosmwasm_std::DepsMut&lt;Empty&gt;,
        env: cosmwasm_std::Env,
        info: cosmwasm_std::MessageInfo,
        msg: Vec&lt;u8&gt;,
    ) -&gt; AnyResult&lt;cosmwasm_std::Response&lt;Empty&gt;&gt; {
        from_slice::&lt;ContractExecMsg&gt;(&amp;msg)?
            .dispatch(self, (deps, env, info))
            .map_err(Into::into)
    }

    fn instantiate(
        &amp;self,
        deps: cosmwasm_std::DepsMut&lt;Empty&gt;,
        env: cosmwasm_std::Env,
        info: cosmwasm_std::MessageInfo,
        msg: Vec&lt;u8&gt;,
    ) -&gt; AnyResult&lt;cosmwasm_std::Response&lt;Empty&gt;&gt; {
        from_slice::&lt;InstantiateMsg&gt;(&amp;msg)?
            .dispatch(self, (deps, env, info))
            .map_err(Into::into)
    }

    fn query(
        &amp;self,
        deps: cosmwasm_std::Deps&lt;Empty&gt;,
        env: cosmwasm_std::Env,
        msg: Vec&lt;u8&gt;,
    ) -&gt; AnyResult&lt;cosmwasm_std::Binary&gt; {
        from_slice::&lt;ContractQueryMsg&gt;(&amp;msg)?
            .dispatch(self, (deps, env))
            .map_err(Into::into)
    }

    fn sudo(
        &amp;self,
        _deps: cosmwasm_std::DepsMut&lt;Empty&gt;,
        _env: cosmwasm_std::Env,
        _msg: Vec&lt;u8&gt;,
    ) -&gt; AnyResult&lt;cosmwasm_std::Response&lt;Empty&gt;&gt; {
        bail!(&quot;sudo not implemented for contract&quot;)
    }

    fn reply(
        &amp;self,
        _deps: cosmwasm_std::DepsMut&lt;Empty&gt;,
        _env: cosmwasm_std::Env,
        _msg: cosmwasm_std::Reply,
    ) -&gt; AnyResult&lt;cosmwasm_std::Response&lt;Empty&gt;&gt; {
        bail!(&quot;reply not implemented for contract&quot;)
    }

    fn migrate(
        &amp;self,
        _deps: cosmwasm_std::DepsMut&lt;Empty&gt;,
        _env: cosmwasm_std::Env,
        _msg: Vec&lt;u8&gt;,
    ) -&gt; AnyResult&lt;cosmwasm_std::Response&lt;Empty&gt;&gt; {
        bail!(&quot;reply not implemented for contract&quot;)
    }
}
</code></pre>
<p>So first, we added <code>mod proxy</code> and <code>mod tests</code>. We will create these files in the next step.</p>
<p>We impl <a href="https://docs.rs/cw-multi-test/0.16.1/cw_multi_test/trait.Contract.html"><code>Contract</code></a><Empty>
for <code>AdminContract</code>. This will allow us to use it in a <code>cw-multi-test</code> environment. To use it, we
have to implement six entry points, but currently, our contract supports only two of them,
<code>instantiate</code> and <code>query</code>. For unsupported entry points, we will call
<a href="https://docs.rs/anyhow/latest/anyhow/macro.bail.html"><code>bail!</code></a>. We will handle supported ones
simmiliary as we did in <code>src/lib.rs</code>. The difference here is that interface <code>Contract</code> forces us to
pass messages to entry points as binary slices. We can work with this by using
<a href="https://docs.rs/cosmwasm-std/0.16.0/cosmwasm_std/fn.from_slice.html"><code>from_slice</code></a>.
This function will parse binary slice to our message. We will then dispatch them as we did in
<code>src/lib.rs</code> entry points and <code>map_err</code> in case any error is returned.</p>
<h2 id="prepare-proxy"><a class="header" href="#prepare-proxy">Prepare proxy</a></h2>
<p>Now we will prepare a proxy for our contract. Our goal here is to remove repetitiveness and hide
serialization from our tests. It will pay off after a while, but you will appreciate this approach
as your contract grows,</p>
<p>Create <code>src/multitest/proxy.rs</code> and paste to it:</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::{Addr, StdResult};
use cw_multi_test::{App, Executor};

use crate::{
    contract::{AdminContract, InstantiateMsg, QueryMsg},
    responses::AdminListResp,
};

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct AdminContractCodeId(u64);

impl AdminContractCodeId {
    pub fn store_code(app: &amp;mut App) -&gt; Self {
        let code_id = app.store_code(Box::new(AdminContract::new()));
        Self(code_id)
    }

    #[track_caller]
    pub fn instantiate(
        self,
        app: &amp;mut App,
        sender: &amp;Addr,
        admins: Vec&lt;String&gt;,
        label: &amp;str,
        admin: Option&lt;String&gt;,
    ) -&gt; StdResult&lt;AdminContractProxy&gt; {
        let msg = InstantiateMsg { admins };

        app.instantiate_contract(self.0, sender.clone(), &amp;msg, &amp;[], label, admin)
            .map_err(|err| err.downcast().unwrap())
            .map(AdminContractProxy)
    }
}

#[derive(Debug)]
pub struct AdminContractProxy(Addr);

impl AdminContractProxy {
    #[track_caller]
    pub fn admin_list(&amp;self, app: &amp;App) -&gt; StdResult&lt;AdminListResp&gt; {
        let msg = QueryMsg::AdminList {};

        app.wrap().query_wasm_smart(self.0.clone(), &amp;msg)
    }
}

</code></pre>
<p>Two new structures here: <code>AdminContractCodeId</code> and <code>AdminContractProxy</code>.
<code>AdminContractCodeId</code> will store <code>u64</code> which represents the code id of our contract registered on
a blockchain generated by <a href="https://docs.rs/cw-multi-test/latest/cw_multi_test/struct.App.html#method.store_code"><code>store_code</code></a>.
We can use <a href="https://docs.rs/cw-multi-test/latest/cw_multi_test/trait.Executor.html#method.instantiate_contract"><code>instantiate_contract</code></a>
with acquired code id and map address of received contract <code>addr</code>. It will on <code>instantiate</code> return
the <code>AdminContractProxy</code>, which responsibility will be to send messages to our contract.</p>
<h2 id="first-multitest"><a class="header" href="#first-multitest">First multitest</a></h2>
<p>Now we are ready to write our first multitest. Let's proceed with creating <code>src/multitest/tests.rs</code>.</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::Addr;
use cw_multi_test::App;

use crate::{multitest::proxy::AdminContractCodeId, responses::AdminListResp};

#[test]
fn basic() {
    let mut app = App::default();

    let owner = Addr::unchecked(&quot;addr0001&quot;);
    let admins = vec![
        &quot;admin1&quot;.to_owned(),
        &quot;admin2&quot;.to_owned(),
        &quot;admin3&quot;.to_owned(),
    ];

    let code_id = AdminContractCodeId::store_code(&amp;mut app);

    let contract = code_id
        .instantiate(&amp;mut app, &amp;owner, admins.clone(), &quot;Cw20 contract&quot;, None)
        .unwrap();

    let resp = contract.admin_list(&amp;app).unwrap();

    assert_eq!(resp, AdminListResp { admins });
}
</code></pre>
<p>We will first create default <a href="https://docs.rs/cw-multi-test/latest/cw_multi_test/struct.App.html#"><code>App</code></a>.
This will cache the state of our contract. We will create an owner of our contract using
<a href="https://docs.rs/cosmwasm-std/0.14.0/cosmwasm_std/struct.Addr.html#method.unchecked"><code>Addr::unchecked</code></a>.
Call <code>store_code</code> on our <code>App</code> to acquire code id and then init the contract which will return
<code>AdminContractProxy</code>.
We instantiate it with three admins, which we will then query using the <code>admin_list</code> method on the
proxy. This should return to us <code>AdminListResp</code> with all three of them.</p>
<p>The test should pass, and we should have our first multitest. We will later expand it when we will
have more functionality to test.
Let's allow our contract to change its state using the <code>execute</code> message in next the chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="execution-messages"><a class="header" href="#execution-messages">Execution messages</a></h1>
<p>We created <code>instantiate</code> and <code>query</code> messages. We have the state in our contract and can test it.
Now let's expand our contract by adding the possibility of updating the state. In this chapter, we
will add the <code>add_member</code> execute message.</p>
<h2 id="custom-error"><a class="header" href="#custom-error">Custom error</a></h2>
<p>Because we don't want non-admins to add new admins to our contract, we will have to take some steps
to prevent it. In case of a call from non-admin we want to return an error that will inform the
users that they are not authorized to perform this kind of operation on contract.
We will achieve this goal by creating our custom error type. It will have to implement
<a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a><StdError> trait to be compatible
with most of the error cases in our contract. It will also have an <code>Unauthorized</code> variant.</p>
<p>First, let's update our <code>Cargo.toml</code> with a new dependency to
<a href="https://docs.rs/thiserror/latest/thiserror/"><code>thiserror</code></a>.</p>
<pre><code class="language-rust noplayground">[package]
name = &quot;contract&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[lib]
crate-type = [&quot;cdylib&quot;]

[features]
library = []

[dependencies]
cosmwasm-std = { version = &quot;1.1&quot;, features = [&quot;staking&quot;] }
cosmwasm-schema = &quot;1.1.6&quot;
serde = { version = &quot;1.0.147&quot;, features = [&quot;derive&quot;] }
sylvia = &quot;0.2.1&quot;
schemars = &quot;0.8.11&quot;
cw-storage-plus = &quot;0.16.0&quot;
thiserror = &quot;1.0.37&quot;

[dev-dependencies]
anyhow = &quot;1&quot;
cw-multi-test = &quot;0.16&quot;
</code></pre>
<p>This error provides us with a derive macro which, we will use to implement our <code>ContractError</code>.
Let's add a new module to our <code>src/lib.rs</code>:</p>
<pre><code class="language-rust noplayground">pub mod contract;
pub mod error;
pub mod responses;

#[cfg(test)]
mod multitest;
<span class="boring">
</span><span class="boring">use contract::{ContractError, ContractQueryMsg};
</span><span class="boring">use cosmwasm_std::{entry_point, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};
</span><span class="boring">
</span><span class="boring">use crate::contract::{AdminContract, InstantiateMsg};
</span><span class="boring">
</span><span class="boring">const CONTRACT: AdminContract = AdminContract::new();
</span><span class="boring">
</span><span class="boring">#[entry_point]
</span><span class="boring">pub fn instantiate(
</span><span class="boring">   deps: DepsMut,
</span><span class="boring">   env: Env,
</span><span class="boring">   info: MessageInfo,
</span><span class="boring">   msg: InstantiateMsg,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">   msg.dispatch(&amp;CONTRACT, (deps, env, info))
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[entry_point]
</span><span class="boring">pub fn query(deps: Deps, env: Env, msg: ContractQueryMsg) -&gt; Result&lt;Binary, ContractError&gt; {
</span><span class="boring">   msg.dispatch(&amp;CONTRACT, (deps, env))
</span><span class="boring">}
</span>
</code></pre>
<p>And now, let's create <code>src/error.rs</code>:</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::{Addr, StdError};
use thiserror::Error;

#[derive(Error, Debug, PartialEq)]
pub enum ContractError {
    #[error(&quot;{0}&quot;)]
    Std(#[from] StdError),
    #[error(&quot;{sender} is not a contract admin&quot;)]
    Unauthorized { sender: Addr },
}
</code></pre>
<p>Our custom error will derive the following traits:</p>
<ul>
<li><a href="https://docs.rs/thiserror/latest/thiserror/derive.Error.html"><code>Error</code></a></li>
<li><code>Debug</code> - for testing purposes</li>
<li><code>PartialEq</code> - for testing purposes</li>
</ul>
<p><code>#[error(_)]</code> will generate Display implementation for our variants. In case of
<code>StdError</code> we want only to forward the error message. In case of our custom <code>Unauthorized</code> variant
user will receive information about who sent the message and why it failed.</p>
<h2 id="impl-execute-message"><a class="header" href="#impl-execute-message">Impl execute message</a></h2>
<p>With the error created, let's implement the message.
It will add a new admin if the sender is an admin.</p>
<pre><code class="language-rust noplayground">use crate::error::ContractError;
use crate::responses::AdminListResp;
use cosmwasm_std::{Addr, Deps, DepsMut, Empty, Env, MessageInfo, Order, Response, StdResult};
use cw_storage_plus::Map;
use schemars;
use sylvia::contract;

<span class="boring">pub struct AdminContract&lt;'a&gt; {
</span><span class="boring">   pub(crate) admins: Map&lt;'a, &amp;'a Addr, Empty&gt;,
</span><span class="boring">}
</span>
#[contract]
impl AdminContract&lt;'_&gt; {
<span class="boring">   pub const fn new() -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">           admins: Map::new(&quot;admins&quot;),
</span><span class="boring">       }
</span><span class="boring">   }
</span>    ...

    #[msg(instantiate)]
    pub fn instantiate(
        &amp;self,
        ctx: (DepsMut, Env, MessageInfo),
        admins: Vec&lt;String&gt;,
    ) -&gt; Result&lt;Response, ContractError&gt; {
        let (deps, _, _) = ctx;

        for admin in admins {
            let admin = deps.api.addr_validate(&amp;admin)?;
            self.admins.save(deps.storage, &amp;admin, &amp;Empty {})?;
        }

        Ok(Response::new())
    }
<span class="boring">
</span><span class="boring">   #[msg(query)]
</span><span class="boring">   pub fn admin_list(&amp;self, ctx: (Deps, Env)) -&gt; StdResult&lt;AdminListResp&gt; {
</span><span class="boring">       let (deps, _) = ctx;
</span><span class="boring">
</span><span class="boring">       let admins: Result&lt;_, _&gt; = self
</span><span class="boring">           .admins
</span><span class="boring">           .keys(deps.storage, None, None, Order::Ascending)
</span><span class="boring">           .map(|addr| addr.map(String::from))
</span><span class="boring">           .collect();
</span><span class="boring">
</span><span class="boring">       Ok(AdminListResp { admins: admins? })
</span><span class="boring">   }
</span>
    #[msg(exec)]
    pub fn add_member(
        &amp;self,
        ctx: (DepsMut, Env, MessageInfo),
        admin: String,
    ) -&gt; Result&lt;Response, ContractError&gt; {
        let (deps, _, info) = ctx;

        if !self.admins.has(deps.storage, &amp;info.sender) {
            return Err(ContractError::Unauthorized {
                sender: info.sender,
            });
        }
        let admin = deps.api.addr_validate(&amp;admin)?;
        self.admins.save(deps.storage, &amp;admin, &amp;Empty {})?;

        Ok(Response::new())
    }
}

#[cfg(test)]
<span class="boring">mod tests {
</span><span class="boring">   use crate::entry_points::{instantiate, query};
</span><span class="boring">   use cosmwasm_std::from_binary;
</span><span class="boring">   use cosmwasm_std::testing::{mock_dependencies, mock_env, mock_info};
</span><span class="boring">
</span><span class="boring">   use super::*;
</span><span class="boring">
</span><span class="boring">   #[test]
</span><span class="boring">   fn admin_list_query() {
</span><span class="boring">       let mut deps = mock_dependencies();
</span><span class="boring">       let env = mock_env();
</span><span class="boring">
</span><span class="boring">       instantiate(
</span><span class="boring">           deps.as_mut(),
</span><span class="boring">           env.clone(),
</span><span class="boring">           mock_info(&quot;sender&quot;, &amp;[]),
</span><span class="boring">           InstantiateMsg {
</span><span class="boring">               admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">           },
</span><span class="boring">       )
</span><span class="boring">       .unwrap();
</span><span class="boring">
</span><span class="boring">       let msg = QueryMsg::AdminList {};
</span><span class="boring">       let resp = query(deps.as_ref(), env, ContractQueryMsg::AdminContract(msg)).unwrap();
</span><span class="boring">       let resp: AdminListResp = from_binary(&amp;resp).unwrap();
</span><span class="boring">       assert_eq!(
</span><span class="boring">           resp,
</span><span class="boring">           AdminListResp {
</span><span class="boring">               admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">           }
</span><span class="boring">       );
</span><span class="boring">   }
</span><span class="boring">}
</span></code></pre>
<p>First, let's add the <code>ContractError</code> to <code>src/contract.rs</code> and delete the old alias. We will update
<code>instantiate</code> to return it instead of the <code>StdError</code>. In the case of a <code>query</code> it is mostly
unnecessary as we rarely check anything in it, but if you have a reason you can also update it. It
is a good approach to define your error type and return it in all but <code>query</code> messages.</p>
<p>To generate <code>execute</code> message we will prefix it with <code>#[msg(exec)]</code>. The return type is the same as
in case of <code>instantiate</code> which is <code>Result&lt;Response, ContractError&gt;</code>.
We will acquire the sender from <code>MessageInfo</code>. In case sender is unathorized a non-admin we
will return its Addr in <code>ContractError::Unauthorized</code>.
Because we can't be sure if the address sent by the admin is correct and represent the actual <code>Addr</code>
in a blockchain we must first call the <code>addr_validate</code> on it. If it's correct we can save it and
return <code>Ok(Response)</code>.</p>
<h2 id="update-entry-points"><a class="header" href="#update-entry-points">Update entry points</a></h2>
<p>Now that we have created the <code>ExecMsg</code>, let's add a new entry point. We have to do it only once
per every type of message, thanks to the dispatch method.</p>
<pre><code class="language-rust noplayground">pub mod contract;
pub mod error;
pub mod responses;

#[cfg(test)]
mod multitest;

use cosmwasm_std::{entry_point, Binary, Deps, DepsMut, Env, MessageInfo, Response};

use crate::contract::{AdminContract, ContractExecMsg, ContractQueryMsg, InstantiateMsg};
use crate::error::ContractError;

const CONTRACT: AdminContract = AdminContract::new();

#[entry_point]
pub fn instantiate(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: InstantiateMsg,
) -&gt; Result&lt;Response, ContractError&gt; {
    msg.dispatch(&amp;CONTRACT, (deps, env, info))
}

#[entry_point]
pub fn query(deps: Deps, env: Env, msg: ContractQueryMsg) -&gt; Result&lt;Binary, ContractError&gt; {
    msg.dispatch(&amp;CONTRACT, (deps, env))
}

#[entry_point]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ContractExecMsg,
) -&gt; Result&lt;Response, ContractError&gt; {
    msg.dispatch(&amp;CONTRACT, (deps, env, info))
}
</code></pre>
<p>Nothing new here. We have the same <code>deps</code>, <code>env</code>, and <code>info</code> variables in the signature as in the
case of <code>instantiate</code>. Our message is <code>ContractExecMsg</code> similar to <code>ContractQueryMsg</code> in case of the
<code>query</code>. The body of the function is simply a <code>dispatch</code> call on the <code>msg</code>. We also updated
instantiate to return <code>ContractError</code>.</p>
<h2 id="unit-testing"><a class="header" href="#unit-testing">Unit testing</a></h2>
<p>Now let's add a simple unit test for <code>execute</code> message.</p>
<pre><code class="language-rust noplayground"><span class="boring">use crate::error::ContractError;
</span><span class="boring">use crate::responses::AdminListResp;
</span><span class="boring">use cosmwasm_std::{Addr, Deps, DepsMut, Empty, Env, MessageInfo, Order, Response, StdResult};
</span><span class="boring">use cw_storage_plus::Map;
</span><span class="boring">use schemars;
</span><span class="boring">use sylvia::contract;
</span><span class="boring">
</span><span class="boring">pub struct AdminContract&lt;'a&gt; {
</span><span class="boring">   pub(crate) admins: Map&lt;'a, &amp;'a Addr, Empty&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[contract]
</span><span class="boring">impl AdminContract&lt;'_&gt; {
</span><span class="boring">   pub const fn new() -&gt; Self {
</span><span class="boring">       Self {
</span><span class="boring">           admins: Map::new(&quot;admins&quot;),
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[msg(instantiate)]
</span><span class="boring">   pub fn instantiate(
</span><span class="boring">       &amp;self,
</span><span class="boring">       ctx: (DepsMut, Env, MessageInfo),
</span><span class="boring">       admins: Vec&lt;String&gt;,
</span><span class="boring">   ) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">       let (deps, _, _) = ctx;
</span><span class="boring">
</span><span class="boring">       for admin in admins {
</span><span class="boring">           let admin = deps.api.addr_validate(&amp;admin)?;
</span><span class="boring">           self.admins.save(deps.storage, &amp;admin, &amp;Empty {})?;
</span><span class="boring">       }
</span><span class="boring">
</span><span class="boring">       Ok(Response::new())
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[msg(query)]
</span><span class="boring">   pub fn admin_list(&amp;self, ctx: (Deps, Env)) -&gt; StdResult&lt;AdminListResp&gt; {
</span><span class="boring">       let (deps, _) = ctx;
</span><span class="boring">
</span><span class="boring">       let admins: Result&lt;_, _&gt; = self
</span><span class="boring">           .admins
</span><span class="boring">           .keys(deps.storage, None, None, Order::Ascending)
</span><span class="boring">           .map(|addr| addr.map(String::from))
</span><span class="boring">           .collect();
</span><span class="boring">
</span><span class="boring">       Ok(AdminListResp { admins: admins? })
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[msg(exec)]
</span><span class="boring">   pub fn add_member(
</span><span class="boring">       &amp;self,
</span><span class="boring">       ctx: (DepsMut, Env, MessageInfo),
</span><span class="boring">       admin: String,
</span><span class="boring">   ) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">       let (deps, _, info) = ctx;
</span><span class="boring">
</span><span class="boring">       if !self.admins.has(deps.storage, &amp;info.sender) {
</span><span class="boring">           return Err(ContractError::Unauthorized {
</span><span class="boring">               sender: info.sender,
</span><span class="boring">           });
</span><span class="boring">       }
</span><span class="boring">       let admin = deps.api.addr_validate(&amp;admin)?;
</span><span class="boring">
</span><span class="boring">       self.admins.save(deps.storage, &amp;admin, &amp;Empty {})?;
</span><span class="boring">
</span><span class="boring">       Ok(Response::new().add_attribute(&quot;action&quot;, &quot;add_member&quot;))
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
<span class="boring">mod tests {
</span>    ...
    
<span class="boring">   use crate::entry_points::{execute, instantiate, query};
</span><span class="boring">   use cosmwasm_std::from_binary;
</span><span class="boring">   use cosmwasm_std::testing::{mock_dependencies, mock_env, mock_info};
</span><span class="boring">
</span><span class="boring">   use super::*;
</span><span class="boring">
</span><span class="boring">   #[test]
</span><span class="boring">   fn admin_list_query() {
</span><span class="boring">       let mut deps = mock_dependencies();
</span><span class="boring">       let env = mock_env();
</span><span class="boring">
</span><span class="boring">       instantiate(
</span><span class="boring">           deps.as_mut(),
</span><span class="boring">           env.clone(),
</span><span class="boring">           mock_info(&quot;sender&quot;, &amp;[]),
</span><span class="boring">           InstantiateMsg {
</span><span class="boring">               admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">           },
</span><span class="boring">       )
</span><span class="boring">       .unwrap();
</span><span class="boring">
</span><span class="boring">       let msg = QueryMsg::AdminList {};
</span><span class="boring">       let resp = query(deps.as_ref(), env, ContractQueryMsg::AdminContract(msg)).unwrap();
</span><span class="boring">       let resp: AdminListResp = from_binary(&amp;resp).unwrap();
</span><span class="boring">       assert_eq!(
</span><span class="boring">           resp,
</span><span class="boring">           AdminListResp {
</span><span class="boring">               admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">           }
</span><span class="boring">       );
</span><span class="boring">   }
</span><span class="boring">
</span>    #[test]
    fn add_member() {
        let mut deps = mock_dependencies();
        let env = mock_env();

        instantiate(
            deps.as_mut(),
            env.clone(),
            mock_info(&quot;sender&quot;, &amp;[]),
            InstantiateMsg {
                admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
            },
        )
        .unwrap();

        let info = mock_info(&quot;admin1&quot;, &amp;[]);
        let msg = ExecMsg::AddMember {
            admin: &quot;admin3&quot;.to_owned(),
        };
        execute(deps.as_mut(), env.clone(), info, ContractExecMsg::AdminContract(msg)).unwrap();

        let msg = QueryMsg::AdminList {};
        let resp = query(deps.as_ref(), env, ContractQueryMsg::AdminContract(msg)).unwrap();
        let resp: AdminListResp = from_binary(&amp;resp).unwrap();
        assert_eq!(
            resp,
            AdminListResp {
                admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned(), &quot;admin3&quot;.to_owned()],
            }
        );
    }
}
</code></pre>
<p>It is very similar to the <code>query</code> test. The difference is the call to the <code>execute</code> entry point with
<code>ContractExecMsg</code>. We created another <code>mock_info</code> instead of reusing one from instantiate because in
a real life scenario <code>MessageInfo</code> is created for every message.</p>
<h2 id="multitest"><a class="header" href="#multitest">Multitest</a></h2>
<p>We have <code>ExecMsg</code> created, the entry point is established for it and we have simple unit test
checking if &quot;Ok case&quot; is working. Time to test it in the <code>multitest</code> enviroment.
First, we will update our proxy. This time we only need to add a call to the <code>add_member</code>.</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::{Addr, StdResult};
use cw_multi_test::{App, AppResponse, Executor};

use crate::{
    contract::{AdminContract, ExecMsg, InstantiateMsg, QueryMsg},
    error::ContractError,
    responses::AdminListResp,
};

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
<span class="boring">pub struct AdminContractCodeId(u64);
</span><span class="boring">
</span><span class="boring">impl AdminContractCodeId {
</span><span class="boring">   pub fn store_code(app: &amp;mut App) -&gt; Self {
</span><span class="boring">       let code_id = app.store_code(Box::new(AdminContract::new()));
</span><span class="boring">       Self(code_id)
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[track_caller]
</span><span class="boring">   pub fn instantiate(
</span><span class="boring">       self,
</span><span class="boring">       app: &amp;mut App,
</span><span class="boring">       sender: &amp;Addr,
</span><span class="boring">       admins: Vec&lt;String&gt;,
</span><span class="boring">       label: &amp;str,
</span><span class="boring">       admin: Option&lt;String&gt;,
</span><span class="boring">   ) -&gt; Result&lt;AdminContractProxy, ContractError&gt; {
</span><span class="boring">       let msg = InstantiateMsg { admins };
</span><span class="boring">
</span><span class="boring">       app.instantiate_contract(self.0, sender.clone(), &amp;msg, &amp;[], label, admin)
</span><span class="boring">           .map_err(|err| err.downcast().unwrap())
</span><span class="boring">           .map(AdminContractProxy)
</span><span class="boring">   }
</span><span class="boring">}
</span>
#[derive(Debug)]
pub struct AdminContractProxy(Addr);

impl AdminContractProxy {
<span class="boring">   #[track_caller]
</span><span class="boring">   pub fn admin_list(&amp;self, app: &amp;App) -&gt; StdResult&lt;AdminListResp&gt; {
</span><span class="boring">       let msg = QueryMsg::AdminList {};
</span><span class="boring">
</span><span class="boring">       app.wrap().query_wasm_smart(self.0.clone(), &amp;msg)
</span><span class="boring">   }
</span><span class="boring">
</span>    #[track_caller]
    pub fn add_member(
        &amp;self,
        app: &amp;mut App,
        sender: &amp;Addr,
        admin: String,
    ) -&gt; Result&lt;AppResponse, ContractError&gt; {
        let msg = ExecMsg::AddMember { admin };

        app.execute_contract(sender.clone(), self.0.clone(), &amp;msg, &amp;[])
            .map_err(|err| err.downcast().unwrap())
    }
}
</code></pre>
<p>You can see that <code>App</code> will return a new type
<a href="https://docs.rs/cw-multi-test/latest/cw_multi_test/struct.AppResponse.html"><code>AppResponse</code></a> from
cw_multi_test rather then <code>Response</code>. As for the body of this method, it is important to pass
<code>sender</code> as <a href="https://docs.rs/cw-multi-test/latest/cw_multi_test/trait.Executor.html#method.execute_contract"><code>execute_contract</code></a> requires it.
We will again pass the empty slice as <code>funds</code> as we don't want to deal with it for now.
We call <code>map_err</code> here, trying to
<a href="https://docs.rs/anyhow/1.0.66/anyhow/struct.Error.html#method.downcast"><code>downcast</code></a> the error to
<code>ContractError</code>.</p>
<p>Now that proxy is ready, let's add a new multitest.
Our scenario will be an <code>error case</code>. An unauthorized user will try to add themselves as an admin
to the contract, which should fail.</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::Addr;
use cw_multi_test::App;

use crate::error::ContractError;
use crate::{multitest::proxy::AdminContractCodeId, responses::AdminListResp};

<span class="boring">#[test]
</span><span class="boring">fn basic() {
</span><span class="boring">   let mut app = App::default();
</span><span class="boring">
</span><span class="boring">   let owner = Addr::unchecked(&quot;addr0001&quot;);
</span><span class="boring">   let admin1 = Addr::unchecked(&quot;admin1&quot;);
</span><span class="boring">   let admin2 = Addr::unchecked(&quot;admin2&quot;);
</span><span class="boring">   let admin3 = Addr::unchecked(&quot;admin3&quot;);
</span><span class="boring">
</span><span class="boring">   let code_id = AdminContractCodeId::store_code(&amp;mut app);
</span><span class="boring">
</span><span class="boring">   let contract = code_id
</span><span class="boring">       .instantiate(
</span><span class="boring">           &amp;mut app,
</span><span class="boring">           &amp;owner,
</span><span class="boring">           vec![admin1.to_string(), admin2.to_string()],
</span><span class="boring">           &quot;Cw20 contract&quot;,
</span><span class="boring">           None,
</span><span class="boring">       )
</span><span class="boring">       .unwrap();
</span><span class="boring">
</span><span class="boring">   let resp = contract.admin_list(&amp;app).unwrap();
</span><span class="boring">
</span><span class="boring">   assert_eq!(
</span><span class="boring">       resp,
</span><span class="boring">       AdminListResp {
</span><span class="boring">           admins: vec![admin1.to_string(), admin2.to_string()]
</span><span class="boring">       }
</span><span class="boring">   );
</span><span class="boring">
</span><span class="boring">   contract
</span><span class="boring">       .add_member(&amp;mut app, &amp;admin1, admin3.to_string())
</span><span class="boring">       .unwrap();
</span><span class="boring">
</span><span class="boring">   let resp = contract.admin_list(&amp;app).unwrap();
</span><span class="boring">
</span><span class="boring">   assert_eq!(
</span><span class="boring">       resp,
</span><span class="boring">       AdminListResp {
</span><span class="boring">           admins: vec![admin1.to_string(), admin2.to_string(), admin3.to_string()]
</span><span class="boring">       }
</span><span class="boring">   );
</span><span class="boring">}
</span><span class="boring">
</span>#[test]
fn unathorized() {
    let mut app = App::default();

    let owner = Addr::unchecked(&quot;addr0001&quot;);
    let admin1 = Addr::unchecked(&quot;admin1&quot;);
    let admin2 = Addr::unchecked(&quot;admin2&quot;);
    let admin3 = Addr::unchecked(&quot;admin3&quot;);

    let code_id = AdminContractCodeId::store_code(&amp;mut app);

    let contract = code_id
        .instantiate(
            &amp;mut app,
            &amp;owner,
            vec![admin1.to_string(), admin2.to_string()],
            &quot;Cw20 contract&quot;,
            None,
        )
        .unwrap();

    let resp = contract.admin_list(&amp;app).unwrap();

    assert_eq!(
        resp,
        AdminListResp {
            admins: vec![admin1.to_string(), admin2.to_string()]
        }
    );

    let err = contract
        .add_member(&amp;mut app, &amp;admin3, admin3.to_string())
        .unwrap_err();

    assert_eq!(err, ContractError::Unauthorized { sender: admin3 });

    let resp = contract.admin_list(&amp;app).unwrap();

    assert_eq!(
        resp,
        AdminListResp {
            admins: vec![admin1.to_string(), admin2.to_string()]
        }
    );
}
</code></pre>
<p>Once again, as in the case of the unit test this is similiar to the <code>query</code> test.
After contract instantiation, we will call <code>add_member</code> with <code>admin3</code> as a sender and catch the error
using <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_err"><code>unwrap_err</code></a>. Then
we will use <code>assert_eq</code> to check if it is <code>ContractError::Unauthorized { sender: &quot;admin3&quot; }</code>.
In the end, we will query the contract for a list of admins, and <code>admin3</code> is not on the list.</p>
<p>Great our contract works as expected, but we could test more scenarios. I encourage
you to think of other edge cases and try to test them by yourself.
We can now add new admins to the contract, but some might want to leave this responsibility.
Try to add new message <code>leave</code> and don't forget to test the new functionality.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="events-attributes-and-data"><a class="header" href="#events-attributes-and-data">Events attributes and data</a></h1>
<p>The only way our contract can communicate to the world, for now, is by queries. Smart contracts are
passive - they cannot invoke any action by themselves. They can do it only as a reaction to a call.
But if you tried playing with wasmd, you know that execution on the blockchain can return some
metadata.</p>
<p>There are two things the contract can return to the caller: events and data. Events are something
produced by almost every real-life smart contract. In contrast, data is rarely used, designed for
contract-to-contract communication.</p>
<h2 id="returning-events"><a class="header" href="#returning-events">Returning events</a></h2>
<p>As an example, we would add an event  admin_added emitted by our contract on the execution of
add_member:</p>
<pre><code class="language-rust noplayground">use crate::error::ContractError;
use crate::responses::AdminListResp;
use cosmwasm_std::{
    Addr, Deps, DepsMut, Empty, Env, Event, MessageInfo, Order, Response, StdResult,
};
use cw_storage_plus::Map;
use schemars;
use sylvia::contract;

<span class="boring">pub struct AdminContract&lt;'a&gt; {
</span><span class="boring">   pub(crate) admins: Map&lt;'a, &amp;'a Addr, Empty&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>#[contract]
impl AdminContract&lt;'_&gt; {
<span class="boring">   pub const fn new() -&gt; Self {
</span><span class="boring">       Self {
</span><span class="boring">           admins: Map::new(&quot;admins&quot;),
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[msg(instantiate)]
</span><span class="boring">   pub fn instantiate(
</span><span class="boring">       &amp;self,
</span><span class="boring">       ctx: (DepsMut, Env, MessageInfo),
</span><span class="boring">       admins: Vec&lt;String&gt;,
</span><span class="boring">   ) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">       let (deps, _, _) = ctx;
</span><span class="boring">
</span><span class="boring">       for admin in admins {
</span><span class="boring">           let admin = deps.api.addr_validate(&amp;admin)?;
</span><span class="boring">           self.admins.save(deps.storage, &amp;admin, &amp;Empty {})?;
</span><span class="boring">       }
</span><span class="boring">
</span><span class="boring">       Ok(Response::new())
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[msg(query)]
</span><span class="boring">   pub fn admin_list(&amp;self, ctx: (Deps, Env)) -&gt; StdResult&lt;AdminListResp&gt; {
</span><span class="boring">       let (deps, _) = ctx;
</span><span class="boring">
</span><span class="boring">       let admins: Result&lt;_, _&gt; = self
</span><span class="boring">           .admins
</span><span class="boring">           .keys(deps.storage, None, None, Order::Ascending)
</span><span class="boring">           .map(|addr| addr.map(String::from))
</span><span class="boring">           .collect();
</span><span class="boring">
</span><span class="boring">       Ok(AdminListResp { admins: admins? })
</span><span class="boring">   }
</span><span class="boring">
</span>    ...

    #[msg(exec)]
    pub fn add_member(
        &amp;self,
        ctx: (DepsMut, Env, MessageInfo),
        admin: String,
    ) -&gt; Result&lt;Response, ContractError&gt; {
        let (deps, _, info) = ctx;

        if !self.admins.has(deps.storage, &amp;info.sender) {
            return Err(ContractError::Unauthorized {
                sender: info.sender,
            });
        }
        let admin = deps.api.addr_validate(&amp;admin)?;
        self.admins.save(deps.storage, &amp;admin, &amp;Empty {})?;

        let resp = Response::new()
            .add_attribute(&quot;action&quot;, &quot;add_member&quot;)
            .add_event(Event::new(&quot;admin_added&quot;).add_attribute(&quot;addr&quot;, admin));
        Ok(resp)
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">   use crate::entry_points::{execute, instantiate, query};
</span><span class="boring">   use cosmwasm_std::from_binary;
</span><span class="boring">   use cosmwasm_std::testing::{mock_dependencies, mock_env, mock_info};
</span><span class="boring">
</span><span class="boring">   use super::*;
</span><span class="boring">
</span><span class="boring">   #[test]
</span><span class="boring">   fn admin_list_query() {
</span><span class="boring">       let mut deps = mock_dependencies();
</span><span class="boring">       let env = mock_env();
</span><span class="boring">
</span><span class="boring">       instantiate(
</span><span class="boring">           deps.as_mut(),
</span><span class="boring">           env.clone(),
</span><span class="boring">           mock_info(&quot;sender&quot;, &amp;[]),
</span><span class="boring">           InstantiateMsg {
</span><span class="boring">               admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">           },
</span><span class="boring">       )
</span><span class="boring">       .unwrap();
</span><span class="boring">
</span><span class="boring">       let msg = QueryMsg::AdminList {};
</span><span class="boring">       let resp = query(deps.as_ref(), env, ContractQueryMsg::AdminContract(msg)).unwrap();
</span><span class="boring">       let resp: AdminListResp = from_binary(&amp;resp).unwrap();
</span><span class="boring">       assert_eq!(
</span><span class="boring">           resp,
</span><span class="boring">           AdminListResp {
</span><span class="boring">               admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">           }
</span><span class="boring">       );
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[test]
</span><span class="boring">   fn add_member() {
</span><span class="boring">       let mut deps = mock_dependencies();
</span><span class="boring">       let env = mock_env();
</span><span class="boring">
</span><span class="boring">       instantiate(
</span><span class="boring">           deps.as_mut(),
</span><span class="boring">           env.clone(),
</span><span class="boring">           mock_info(&quot;sender&quot;, &amp;[]),
</span><span class="boring">           InstantiateMsg {
</span><span class="boring">               admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">           },
</span><span class="boring">       )
</span><span class="boring">       .unwrap();
</span><span class="boring">
</span><span class="boring">       let info = mock_info(&quot;admin1&quot;, &amp;[]);
</span><span class="boring">       let msg = ExecMsg::AddMember {
</span><span class="boring">           admin: &quot;admin3&quot;.to_owned(),
</span><span class="boring">       };
</span><span class="boring">       execute(
</span><span class="boring">           deps.as_mut(),
</span><span class="boring">           env.clone(),
</span><span class="boring">           info,
</span><span class="boring">           ContractExecMsg::AdminContract(msg),
</span><span class="boring">       )
</span><span class="boring">       .unwrap();
</span><span class="boring">
</span><span class="boring">       let msg = QueryMsg::AdminList {};
</span><span class="boring">       let resp = query(deps.as_ref(), env, ContractQueryMsg::AdminContract(msg)).unwrap();
</span><span class="boring">       let resp: AdminListResp = from_binary(&amp;resp).unwrap();
</span><span class="boring">       assert_eq!(
</span><span class="boring">           resp,
</span><span class="boring">           AdminListResp {
</span><span class="boring">               admins: vec![
</span><span class="boring">                   &quot;admin1&quot;.to_owned(),
</span><span class="boring">                   &quot;admin2&quot;.to_owned(),
</span><span class="boring">                   &quot;admin3&quot;.to_owned()
</span><span class="boring">               ],
</span><span class="boring">           }
</span><span class="boring">       );
</span><span class="boring">   }
</span><span class="boring">}
</span></code></pre>
<p>An event is built from two things: an event type provided in the
<a href="https://docs.rs/cosmwasm-std/1.1.0/cosmwasm_std/struct.Event.html#method.new"><code>new</code></a> function and
attributes. Attributes are added to an event with the
<a href="https://docs.rs/cosmwasm-std/1.1.0/cosmwasm_std/struct.Event.html#method.add_attributes"><code>add_attributes</code></a>
or the <a href="https://docs.rs/cosmwasm-std/1.1.0/cosmwasm_std/struct.Event.html#method.add_attribute"><code>add_attribute</code></a>
call. Attributes are key-value pairs. Because an event cannot contain any list, to achieve reporting
multiple similar actions taking place, we need to emit multiple small events instead of a collective
one.</p>
<p>Events are emitted by adding them to the response with
<a href="https://docs.rs/cosmwasm-std/1.1.0/cosmwasm_std/struct.Response.html#method.add_event"><code>add_event</code></a>
or <a href="https://docs.rs/cosmwasm-std/1.1.0/cosmwasm_std/struct.Response.html#method.add_events"><code>add_events</code></a>
call. Additionally, there is a possibility to add attributes directly to the response. It is just
sugar. By default, every execution emits a standard &quot;wasm&quot; event. Adding attributes to the result
adds them to the default event.</p>
<p>We can check if events are properly emitted by contract. It is not always done, as it is much of
boilerplate in test, but events are, generally, more like logs - not necessarily considered the main
contract logic.</p>
<p>Due to the extra event attribute being added by contract, let's add a new method to the proxy:</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::{Addr, StdResult};
use cw_multi_test::{App, AppResponse, Executor};

use crate::{
    contract::{AdminContract, ExecMsg, InstantiateMsg, QueryMsg},
    error::ContractError,
    responses::AdminListResp,
};

<span class="boring">#[derive(Clone, Copy, Debug, PartialEq, Eq)]
</span><span class="boring">pub struct AdminContractCodeId(u64);
</span><span class="boring">
</span><span class="boring">impl AdminContractCodeId {
</span><span class="boring">   pub fn store_code(app: &amp;mut App) -&gt; Self {
</span><span class="boring">       let code_id = app.store_code(Box::new(AdminContract::new()));
</span><span class="boring">       Self(code_id)
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[track_caller]
</span><span class="boring">   pub fn instantiate(
</span><span class="boring">       self,
</span><span class="boring">       app: &amp;mut App,
</span><span class="boring">       sender: &amp;Addr,
</span><span class="boring">       admins: Vec&lt;String&gt;,
</span><span class="boring">       label: &amp;str,
</span><span class="boring">       admin: Option&lt;String&gt;,
</span><span class="boring">   ) -&gt; Result&lt;AdminContractProxy, ContractError&gt; {
</span><span class="boring">       let msg = InstantiateMsg { admins };
</span><span class="boring">
</span><span class="boring">       app.instantiate_contract(self.0, sender.clone(), &amp;msg, &amp;[], label, admin)
</span><span class="boring">           .map_err(|err| err.downcast().unwrap())
</span><span class="boring">           .map(AdminContractProxy)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">pub struct AdminContractProxy(Addr);
</span><span class="boring">
</span>impl AdminContractProxy {
    pub fn addr(&amp;self) -&gt; &amp;Addr {
        &amp;self.0
    }
<span class="boring">   #[track_caller]
</span><span class="boring">   pub fn admin_list(&amp;self, app: &amp;App) -&gt; StdResult&lt;AdminListResp&gt; {
</span><span class="boring">       let msg = QueryMsg::AdminList {};
</span><span class="boring">
</span><span class="boring">       app.wrap().query_wasm_smart(self.0.clone(), &amp;msg)
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[track_caller]
</span><span class="boring">   pub fn add_member(
</span><span class="boring">       &amp;self,
</span><span class="boring">       app: &amp;mut App,
</span><span class="boring">       sender: &amp;Addr,
</span><span class="boring">       admin: String,
</span><span class="boring">   ) -&gt; Result&lt;AppResponse, ContractError&gt; {
</span><span class="boring">       let msg = ExecMsg::AddMember { admin };
</span><span class="boring">
</span><span class="boring">       app.execute_contract(sender.clone(), self.0.clone(), &amp;msg, &amp;[])
</span><span class="boring">           .map_err(|err| err.downcast().unwrap())
</span><span class="boring">   }
</span>}
</code></pre>
<p>This will return the address of the contract on a blockchain which is, by default, added to the
events attribute and which we will need in our assertion. Now let's update our basic multitest
checking if execution emits events:</p>
<pre><code class="language-rust noplayground/If">use cosmwasm_std::{Addr, Event};
use cw_multi_test::App;

use crate::error::ContractError;
use crate::{multitest::proxy::AdminContractCodeId, responses::AdminListResp};

#[test]
fn basic() {
    let mut app = App::default();

    let owner = Addr::unchecked(&quot;addr0001&quot;);
    let admin1 = Addr::unchecked(&quot;admin1&quot;);
    let admin2 = Addr::unchecked(&quot;admin2&quot;);
    let admin3 = Addr::unchecked(&quot;admin3&quot;);

    let code_id = AdminContractCodeId::store_code(&amp;mut app);

    let contract = code_id
        .instantiate(
            &amp;mut app,
            &amp;owner,
            vec![admin1.to_string(), admin2.to_string()],
            &quot;Cw20 contract&quot;,
            None,
        )
        .unwrap();

    let resp = contract.admin_list(&amp;app).unwrap();

    assert_eq!(
        resp,
        AdminListResp {
            admins: vec![admin1.to_string(), admin2.to_string()]
        }
    );

    let resp = contract
        .add_member(&amp;mut app, &amp;admin1, admin3.to_string())
        .unwrap();

    let wasm = resp.events.iter().find(|ev| ev.ty == &quot;wasm&quot;).unwrap();
    assert_eq!(
        wasm.attributes
            .iter()
            .find(|attr| attr.key == &quot;action&quot;)
            .unwrap()
            .value,
        &quot;add_member&quot;
    );

    let admin_added: Vec&lt;_&gt; = resp
        .events
        .iter()
        .filter(|ev| ev.ty == &quot;wasm-admin_added&quot;)
        .collect();
    assert_eq!(admin_added[0], &amp;Event::new(&quot;wasm-admin_added&quot;).add_attribute(&quot;_contract_addr&quot;, contract.addr()).add_attribute(&quot;addr&quot;, Addr::unchecked(&quot;admin3&quot;)));

    let resp = contract.admin_list(&amp;app).unwrap();

    assert_eq!(
        resp,
        AdminListResp {
            admins: vec![admin1.to_string(), admin2.to_string(), admin3.to_string()]
        }
    );
}
<span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn unathorized() {
</span><span class="boring">   let mut app = App::default();
</span><span class="boring">
</span><span class="boring">   let owner = Addr::unchecked(&quot;addr0001&quot;);
</span><span class="boring">   let admin1 = Addr::unchecked(&quot;admin1&quot;);
</span><span class="boring">   let admin2 = Addr::unchecked(&quot;admin2&quot;);
</span><span class="boring">   let admin3 = Addr::unchecked(&quot;admin3&quot;);
</span><span class="boring">
</span><span class="boring">   let code_id = AdminContractCodeId::store_code(&amp;mut app);
</span><span class="boring">
</span><span class="boring">   let contract = code_id
</span><span class="boring">       .instantiate(
</span><span class="boring">           &amp;mut app,
</span><span class="boring">           &amp;owner,
</span><span class="boring">           vec![admin1.to_string(), admin2.to_string()],
</span><span class="boring">           &quot;Cw20 contract&quot;,
</span><span class="boring">           None,
</span><span class="boring">       )
</span><span class="boring">       .unwrap();
</span><span class="boring">
</span><span class="boring">   let resp = contract.admin_list(&amp;app).unwrap();
</span><span class="boring">
</span><span class="boring">   assert_eq!(
</span><span class="boring">       resp,
</span><span class="boring">       AdminListResp {
</span><span class="boring">           admins: vec![admin1.to_string(), admin2.to_string()]
</span><span class="boring">       }
</span><span class="boring">   );
</span><span class="boring">
</span><span class="boring">   let err = contract
</span><span class="boring">       .add_member(&amp;mut app, &amp;admin3, admin3.to_string())
</span><span class="boring">       .unwrap_err();
</span><span class="boring">
</span><span class="boring">   assert_eq!(err, ContractError::Unauthorized { sender: admin3 });
</span><span class="boring">
</span><span class="boring">   let resp = contract.admin_list(&amp;app).unwrap();
</span><span class="boring">
</span><span class="boring">   assert_eq!(
</span><span class="boring">       resp,
</span><span class="boring">       AdminListResp {
</span><span class="boring">           admins: vec![admin1.to_string(), admin2.to_string()]
</span><span class="boring">       }
</span><span class="boring">   );
</span><span class="boring">}
</span></code></pre>
<p>If you have prepared an Ok scenario test after the previous chapter, then you can update it as
above. I have added the <code>add_member</code> call in the <code>basic</code> test and captured the response in the
<code>resp</code> variable.</p>
<p>As you can see, testing events on a simple test made it clunky. First of all, every string is
heavily string-based - a lack of type control makes writing such tests difficult. Also, event types
are prefixed with &quot;wasm-&quot; - it may not be a huge problem, but it doesn't clarify verification. But
the problem is, how layered event structures are, which makes verifying them tricky. Also, the
&quot;wasm&quot; event is particularly tricky, as it contains an implied attribute - <code>_contract_addr</code>
containing an address called a contract. My general rule is - do not test emitted events unless
some logic depends on them.</p>
<h2 id="data"><a class="header" href="#data">Data</a></h2>
<p>Besides events, any smart contract execution may produce a <code>data</code> object. In contrast to events,
<code>data</code> can be structured. It makes it a way better choice to perform any communication logic to
rely on it. On the other hand, it turns out it is very rarely helpful outside of contract-to-contract
communication. Data is always only one single object on the response, which is set using the
<a href="https://docs.rs/cosmwasm-std/1.1.0/cosmwasm_std/struct.Response.html#method.set_data"><code>set_data</code></a>
function. Because of its low usefulness in a single contract environment, we will not spend time on
it right now - an example of it will be covered later when contract-to-contract communication will
be discussed. Until then, it is just helpful to know such an entity exists.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dealing-with-funds"><a class="header" href="#dealing-with-funds">Dealing with funds</a></h1>
<p>When you hear smart contracts, you think of blockchain. When you hear blockchain, you often think of
cryptocurrencies. It is not the same, but crypto assets, or as we often call them: tokens, are very
closely connected to the blockchain. CosmWasm has a notion of a native token. Native tokens are
assets managed by the blockchain core instead of smart contracts. Often such assets have some
special meaning, like being used for paying gas fees or staking for consensus algorithm, but can be
just arbitrary assets.</p>
<p>Native tokens are assigned to their owners but can be transferred by their nature. Everything had an
address in the blockchain is eligible to have its native tokens. As a consequence - tokens can be
assigned to smart contracts! Every message sent to the smart contract can have some funds sent
with it. In this chapter, we will take advantage of that and create a way to reward the hard work
performed by admins. We will create a new message - Donate, which anyone can use to donate some
funds to admins, divided equally.</p>
<h2 id="preparing-messages"><a class="header" href="#preparing-messages">Preparing messages</a></h2>
<p>Traditionally we need to prepare our messages. We need to create a new ExecuteMsg variant, but
we will also modify the Instantiate message a bit - we need to have some way of defining the
name of a native token we would use for donations. It would be possible to allow users to send any
tokens they want, but we want to simplify things for now.</p>
<pre><code class="language-rust noplayground">use crate::error::ContractError;
use crate::responses::AdminListResp;
use cosmwasm_std::{
    Addr, Deps, DepsMut, Empty, Env, Event, MessageInfo, Order, Response, StdResult,
};
use cw_storage_plus::{Map, Item};
use schemars;
use sylvia::contract;

pub struct AdminContract&lt;'a&gt; {
    pub(crate) admins: Map&lt;'a, &amp;'a Addr, Empty&gt;,
    pub(crate) donation_denom: Item&lt;'a, String&gt;,
}

#[contract]
impl AdminContract&lt;'_&gt; {
    pub const fn new() -&gt; Self {
        Self {
            admins: Map::new(&quot;admins&quot;),
            donation_denom: Item::new(&quot;donation_denom&quot;),
        }
    }

    #[msg(instantiate)]
    pub fn instantiate(
        &amp;self,
        ctx: (DepsMut, Env, MessageInfo),
        admins: Vec&lt;String&gt;,
        donation_denom: String,
    ) -&gt; Result&lt;Response, ContractError&gt; {
        let (deps, _, _) = ctx;

        for admin in admins {
            let admin = deps.api.addr_validate(&amp;admin)?;
            self.admins.save(deps.storage, &amp;admin, &amp;Empty {})?;
        }
        self.donation_denom.save(deps.storage, &amp;donation_denom)?;
        Ok(Response::new())
    }
<span class="boring">
</span><span class="boring">   #[msg(query)]
</span><span class="boring">   pub fn admin_list(&amp;self, ctx: (Deps, Env)) -&gt; StdResult&lt;AdminListResp&gt; {
</span><span class="boring">       let (deps, _) = ctx;
</span><span class="boring">
</span><span class="boring">       let admins: Result&lt;_, _&gt; = self
</span><span class="boring">           .admins
</span><span class="boring">           .keys(deps.storage, None, None, Order::Ascending)
</span><span class="boring">           .map(|addr| addr.map(String::from))
</span><span class="boring">           .collect();
</span><span class="boring">
</span><span class="boring">       Ok(AdminListResp { admins: admins? })
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[msg(exec)]
</span><span class="boring">   pub fn add_member(
</span><span class="boring">       &amp;self,
</span><span class="boring">       ctx: (DepsMut, Env, MessageInfo),
</span><span class="boring">       admin: String,
</span><span class="boring">   ) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">       let (deps, _, info) = ctx;
</span><span class="boring">
</span><span class="boring">       if !self.admins.has(deps.storage, &amp;info.sender) {
</span><span class="boring">           return Err(ContractError::Unauthorized {
</span><span class="boring">               sender: info.sender,
</span><span class="boring">           });
</span><span class="boring">       }
</span><span class="boring">       let admin = deps.api.addr_validate(&amp;admin)?;
</span><span class="boring">       let resp = Response::new().add_attribute(&quot;action&quot;, &quot;add_member&quot;);
</span><span class="boring">       self.admins.save(deps.storage, &amp;admin, &amp;Empty {})?;
</span><span class="boring">       let resp = resp.add_event(Event::new(&quot;admin_added&quot;).add_attribute(&quot;addr&quot;, admin));
</span><span class="boring">       Ok(resp)
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[msg(exec)]
</span><span class="boring">   pub fn leave(&amp;self, ctx: (DepsMut, Env, MessageInfo)) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">       let (deps, _, info) = ctx;
</span><span class="boring">
</span><span class="boring">       self.admins.remove(deps.storage, &amp;info.sender);
</span><span class="boring">
</span><span class="boring">       Ok(Response::new().add_attribute(&quot;action&quot;, &quot;leave&quot;))
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">   use crate::entry_points::{execute, instantiate, query};
</span><span class="boring">   use cosmwasm_std::from_binary;
</span><span class="boring">   use cosmwasm_std::testing::{mock_dependencies, mock_env, mock_info};
</span><span class="boring">
</span><span class="boring">   use super::*;
</span><span class="boring">
</span><span class="boring">   const ATOM: &amp;str = &quot;atom&quot;;
</span><span class="boring">
</span><span class="boring">   #[test]
</span><span class="boring">   fn admin_list_query() {
</span><span class="boring">       let mut deps = mock_dependencies();
</span><span class="boring">       let env = mock_env();
</span><span class="boring">
</span><span class="boring">       instantiate(
</span><span class="boring">           deps.as_mut(),
</span><span class="boring">           env.clone(),
</span><span class="boring">           mock_info(&quot;sender&quot;, &amp;[]),
</span><span class="boring">           InstantiateMsg {
</span><span class="boring">               admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">               donation_denom: ATOM.to_owned(),
</span><span class="boring">           },
</span><span class="boring">
</span><span class="boring">       )
</span><span class="boring">       .unwrap();
</span><span class="boring">
</span><span class="boring">       let msg = QueryMsg::AdminList {};
</span><span class="boring">       let resp = query(deps.as_ref(), env, ContractQueryMsg::AdminContract(msg)).unwrap();
</span><span class="boring">       let resp: AdminListResp = from_binary(&amp;resp).unwrap();
</span><span class="boring">       assert_eq!(
</span><span class="boring">           resp,
</span><span class="boring">           AdminListResp {
</span><span class="boring">               admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">           }
</span><span class="boring">       );
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[test]
</span><span class="boring">   fn add_member() {
</span><span class="boring">       let mut deps = mock_dependencies();
</span><span class="boring">       let env = mock_env();
</span><span class="boring">
</span><span class="boring">       instantiate(
</span><span class="boring">           deps.as_mut(),
</span><span class="boring">           env.clone(),
</span><span class="boring">           mock_info(&quot;sender&quot;, &amp;[]),
</span><span class="boring">           InstantiateMsg {
</span><span class="boring">               admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">               donation_denom: ATOM.to_owned(),
</span><span class="boring">           },
</span><span class="boring">       )
</span><span class="boring">       .unwrap();
</span><span class="boring">
</span><span class="boring">       let info = mock_info(&quot;admin1&quot;, &amp;[]);
</span><span class="boring">       let msg = ExecMsg::AddMember {
</span><span class="boring">           admin: &quot;admin3&quot;.to_owned(),
</span><span class="boring">       };
</span><span class="boring">       execute(
</span><span class="boring">           deps.as_mut(),
</span><span class="boring">           env.clone(),
</span><span class="boring">           info,
</span><span class="boring">           ContractExecMsg::AdminContract(msg),
</span><span class="boring">       )
</span><span class="boring">       .unwrap();
</span><span class="boring">
</span><span class="boring">       let msg = QueryMsg::AdminList {};
</span><span class="boring">       let resp = query(deps.as_ref(), env, ContractQueryMsg::AdminContract(msg)).unwrap();
</span><span class="boring">       let resp: AdminListResp = from_binary(&amp;resp).unwrap();
</span><span class="boring">       assert_eq!(
</span><span class="boring">           resp,
</span><span class="boring">           AdminListResp {
</span><span class="boring">               admins: vec![
</span><span class="boring">                   &quot;admin1&quot;.to_owned(),
</span><span class="boring">                   &quot;admin2&quot;.to_owned(),
</span><span class="boring">                   &quot;admin3&quot;.to_owned()
</span><span class="boring">               ],
</span><span class="boring">           }
</span><span class="boring">       )
</span><span class="boring">   }
</span><span class="boring">}
</span></code></pre>
<p>We have added a new state <code>donation_denom</code>, which is of type
<a href="https://docs.rs/cw-storage-plus/latest/cw_storage_plus/struct.Item.html"><code>Item</code></a>. A user has to
pass a new value to instantiate the contract. I will let you fix tests, which should at this point
fail due to missing parameter.</p>
<p>Let's update our <code>Cargo.toml</code> with a new dependency to
<a href="https://docs.rs/cw-utils/latest/cw_utils/"><code>cw-utils</code></a>.</p>
<pre><code class="language-rust noplayground">[package]
name = &quot;contract&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[lib]
crate-type = [&quot;cdylib&quot;]

[features]
library = []

[dependencies]
cosmwasm-std = { version = &quot;1.1&quot;, features = [&quot;staking&quot;] }
cosmwasm-schema = &quot;1.1.6&quot;
serde = { version = &quot;1.0.147&quot;, features = [&quot;derive&quot;] }
sylvia = &quot;0.2.1&quot;
schemars = &quot;0.8.11&quot;
thiserror = &quot;1.0.37&quot;
cw-storage-plus = &quot;0.16.0&quot;
cw-utils = &quot;0.16&quot;

[dev-dependencies]
anyhow = &quot;1&quot;
cw-multi-test = &quot;0.16&quot;
</code></pre>
<p>Now let's implement the new <code>donate</code> message.</p>
<pre><code class="language-rust noplayground">use crate::error::ContractError;
use crate::responses::AdminListResp;
use cosmwasm_std::{
    Addr, Deps, DepsMut, Empty, Env, Event, MessageInfo, Order, Response, StdResult, StdError, BankMsg, coins,
};
use cw_storage_plus::{Map, Item};
use schemars;
use sylvia::contract;

pub struct AdminContract&lt;'a&gt; {
    pub(crate) admins: Map&lt;'a, &amp;'a Addr, Empty&gt;,
    pub(crate) donation_denom: Item&lt;'a, String&gt;,
}

#[contract]
impl AdminContract&lt;'_&gt; {
<span class="boring">   pub const fn new() -&gt; Self {
</span><span class="boring">       Self {
</span><span class="boring">           admins: Map::new(&quot;admins&quot;),
</span><span class="boring">           donation_denom: Item::new(&quot;donation_denom&quot;),
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[msg(instantiate)]
</span><span class="boring">   pub fn instantiate(
</span><span class="boring">       &amp;self,
</span><span class="boring">       ctx: (DepsMut, Env, MessageInfo),
</span><span class="boring">       admins: Vec&lt;String&gt;,
</span><span class="boring">       donation_denom: String,
</span><span class="boring">   ) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">       let (deps, _, _) = ctx;
</span><span class="boring">
</span><span class="boring">       for admin in admins {
</span><span class="boring">           let admin = deps.api.addr_validate(&amp;admin)?;
</span><span class="boring">           self.admins.save(deps.storage, &amp;admin, &amp;Empty {})?;
</span><span class="boring">       }
</span><span class="boring">       self.donation_denom.save(deps.storage, &amp;donation_denom)?;
</span><span class="boring">       Ok(Response::new())
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[msg(query)]
</span><span class="boring">   pub fn admin_list(&amp;self, ctx: (Deps, Env)) -&gt; StdResult&lt;AdminListResp&gt; {
</span><span class="boring">       let (deps, _) = ctx;
</span><span class="boring">
</span><span class="boring">       let admins: Result&lt;_, _&gt; = self
</span><span class="boring">           .admins
</span><span class="boring">           .keys(deps.storage, None, None, Order::Ascending)
</span><span class="boring">           .map(|addr| addr.map(String::from))
</span><span class="boring">           .collect();
</span><span class="boring">
</span><span class="boring">       Ok(AdminListResp { admins: admins? })
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[msg(exec)]
</span><span class="boring">   pub fn add_member(
</span><span class="boring">       &amp;self,
</span><span class="boring">       ctx: (DepsMut, Env, MessageInfo),
</span><span class="boring">       admin: String,
</span><span class="boring">   ) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">       let (deps, _, info) = ctx;
</span><span class="boring">
</span><span class="boring">       if !self.admins.has(deps.storage, &amp;info.sender) {
</span><span class="boring">           return Err(ContractError::Unauthorized {
</span><span class="boring">               sender: info.sender,
</span><span class="boring">           });
</span><span class="boring">       }
</span><span class="boring">       let admin = deps.api.addr_validate(&amp;admin)?;
</span><span class="boring">       let resp = Response::new().add_attribute(&quot;action&quot;, &quot;add_member&quot;);
</span><span class="boring">       self.admins.save(deps.storage, &amp;admin, &amp;Empty {})?;
</span><span class="boring">       let resp = resp.add_event(Event::new(&quot;admin_added&quot;).add_attribute(&quot;addr&quot;, admin));
</span><span class="boring">       Ok(resp)
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[msg(exec)]
</span><span class="boring">   pub fn leave(&amp;self, ctx: (DepsMut, Env, MessageInfo)) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">       let (deps, _, info) = ctx;
</span><span class="boring">
</span><span class="boring">       self.admins.remove(deps.storage, &amp;info.sender);
</span><span class="boring">
</span><span class="boring">       Ok(Response::new().add_attribute(&quot;action&quot;, &quot;leave&quot;))
</span><span class="boring">   }
</span><span class="boring">
</span>    ...
    #[msg(exec)]
    pub fn donate(&amp;self, ctx: (DepsMut, Env, MessageInfo)) -&gt; Result&lt;Response, ContractError&gt; {
        let (deps, _, info) = ctx;

        let denom = self.donation_denom.load(deps.storage)?;
        let admins_len = self
            .admins
            .keys(deps.storage, None, None, Order::Ascending)
            .filter_map(|admin| admin.ok())
            .count();

        let donation = cw_utils::must_pay(&amp;info, &amp;denom)
            .map_err(|err| StdError::generic_err(err.to_string()))?
            .u128();

        let donation_per_admin = donation / (admins_len as u128);

        let admins = self
            .admins
            .keys(deps.storage, None, None, Order::Ascending)
            .filter_map(|admin| admin.ok());

        let messages = admins.into_iter().map(|admin| BankMsg::Send {
            to_address: admin.to_string(),
            amount: coins(donation_per_admin, &amp;denom),
        });

        let resp = Response::new()
            .add_messages(messages)
            .add_attribute(&quot;action&quot;, &quot;donate&quot;)
            .add_attribute(&quot;amount&quot;, donation.to_string())
            .add_attribute(&quot;per_admin&quot;, donation_per_admin.to_string());

        Ok(resp)
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">   use crate::entry_points::{execute, instantiate, query};
</span><span class="boring">   use cosmwasm_std::from_binary;
</span><span class="boring">   use cosmwasm_std::testing::{mock_dependencies, mock_env, mock_info};
</span><span class="boring">
</span><span class="boring">   use super::*;
</span><span class="boring">
</span><span class="boring">   const ATOM: &amp;str = &quot;atom&quot;;
</span><span class="boring">
</span><span class="boring">   #[test]
</span><span class="boring">   fn admin_list_query() {
</span><span class="boring">       let mut deps = mock_dependencies();
</span><span class="boring">       let env = mock_env();
</span><span class="boring">
</span><span class="boring">       instantiate(
</span><span class="boring">           deps.as_mut(),
</span><span class="boring">           env.clone(),
</span><span class="boring">           mock_info(&quot;sender&quot;, &amp;[]),
</span><span class="boring">           InstantiateMsg {
</span><span class="boring">               admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">               donation_denom: ATOM.to_owned(),
</span><span class="boring">           },
</span><span class="boring">
</span><span class="boring">       )
</span><span class="boring">       .unwrap();
</span><span class="boring">
</span><span class="boring">       let msg = QueryMsg::AdminList {};
</span><span class="boring">       let resp = query(deps.as_ref(), env, ContractQueryMsg::AdminContract(msg)).unwrap();
</span><span class="boring">       let resp: AdminListResp = from_binary(&amp;resp).unwrap();
</span><span class="boring">       assert_eq!(
</span><span class="boring">           resp,
</span><span class="boring">           AdminListResp {
</span><span class="boring">               admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">           }
</span><span class="boring">       );
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[test]
</span><span class="boring">   fn add_member() {
</span><span class="boring">       let mut deps = mock_dependencies();
</span><span class="boring">       let env = mock_env();
</span><span class="boring">
</span><span class="boring">       instantiate(
</span><span class="boring">           deps.as_mut(),
</span><span class="boring">           env.clone(),
</span><span class="boring">           mock_info(&quot;sender&quot;, &amp;[]),
</span><span class="boring">           InstantiateMsg {
</span><span class="boring">               admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">               donation_denom: ATOM.to_owned(),
</span><span class="boring">           },
</span><span class="boring">       )
</span><span class="boring">       .unwrap();
</span><span class="boring">
</span><span class="boring">       let info = mock_info(&quot;admin1&quot;, &amp;[]);
</span><span class="boring">       let msg = ExecMsg::AddMember {
</span><span class="boring">           admin: &quot;admin3&quot;.to_owned(),
</span><span class="boring">       };
</span><span class="boring">       execute(
</span><span class="boring">           deps.as_mut(),
</span><span class="boring">           env.clone(),
</span><span class="boring">           info,
</span><span class="boring">           ContractExecMsg::AdminContract(msg),
</span><span class="boring">       )
</span><span class="boring">       .unwrap();
</span><span class="boring">
</span><span class="boring">       let msg = QueryMsg::AdminList {};
</span><span class="boring">       let resp = query(deps.as_ref(), env, ContractQueryMsg::AdminContract(msg)).unwrap();
</span><span class="boring">       let resp: AdminListResp = from_binary(&amp;resp).unwrap();
</span><span class="boring">       assert_eq!(
</span><span class="boring">           resp,
</span><span class="boring">           AdminListResp {
</span><span class="boring">               admins: vec![
</span><span class="boring">                   &quot;admin1&quot;.to_owned(),
</span><span class="boring">                   &quot;admin2&quot;.to_owned(),
</span><span class="boring">                   &quot;admin3&quot;.to_owned()
</span><span class="boring">               ],
</span><span class="boring">           }
</span><span class="boring">       );
</span><span class="boring">   }
</span><span class="boring">}
</span>
</code></pre>
<p>Sending the funds to another contract is performed by adding bank messages to the response.
The blockchain would expect any message which is returned in contract response as a part of an
execution. This design is related to an actor model implemented by CosmWasm. The whole actor model
will be described in detail later. For now, you can assume this is a way to handle token transfers.
Before sending tokens to admins, we have to calculate the amount of dotation per admin. It is done
by searching funds for an entry describing our donation token and dividing the number of tokens
sent by the number of admins. Note that because the integral division is always rounding down.</p>
<p>As a consequence, it is possible that not all tokens sent as a donation would end up with no admins
accounts. Any leftover would be left on our contract account forever. There are plenty of ways of
dealing with this issue - figuring out one of them would be a great exercise.</p>
<p>The last missing part is updating the ContractError - the must_pay call returns a
<a href="https://docs.rs/cw-utils/latest/cw_utils/enum.PaymentError.html"><code>PaymentError</code></a>
which we can't convert to our error type yet:</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::{Addr, StdError};
use cw_utils::PaymentError;
use thiserror::Error;

#[derive(Error, Debug, PartialEq)]
pub enum ContractError {
    #[error(&quot;{0}&quot;)]
    Std(#[from] StdError),
    #[error(&quot;{sender} is not a contract admin&quot;)]
    Unauthorized { sender: Addr },
    #[error(&quot;Payment error: {0}&quot;)]
    Payment(#[from] PaymentError)
}
</code></pre>
<p>As you can see, to handle incoming funds, I used the utility function - I encourage you to take
a look at its <a href="https://docs.rs/cw-utils/0.13.4/src/cw_utils/payment.rs.html#32-39"><code>implementation</code></a>
- this would give you a good understanding of how incoming funds are structured in <code>MessageInfo</code>.</p>
<p>Now it's time to check if the funds are distributed correctly. The way for that is to write a test.
First let's update <code>src/multitest/proxy.rs</code></p>
<pre><code class="language-rust noplayground">use cosmwasm_std::{Addr, Coin, StdResult};
use cw_multi_test::{App, AppResponse, Executor};

use crate::{
    contract::{AdminContract, ExecMsg, InstantiateMsg, QueryMsg},
    error::ContractError,
    responses::AdminListResp,
};
<span class="boring">
</span>#[derive(Clone, Copy, Debug, PartialEq, Eq)]
<span class="boring">pub struct AdminContractCodeId(u64);
</span><span class="boring">
</span><span class="boring">impl AdminContractCodeId {
</span><span class="boring">   pub fn store_code(app: &amp;mut App) -&gt; Self {
</span><span class="boring">       let code_id = app.store_code(Box::new(AdminContract::new()));
</span><span class="boring">       Self(code_id)
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[track_caller]
</span><span class="boring">   pub fn instantiate(
</span><span class="boring">       self,
</span><span class="boring">       app: &amp;mut App,
</span><span class="boring">       sender: &amp;Addr,
</span><span class="boring">       admins: Vec&lt;String&gt;,
</span><span class="boring">       donation_denom: String,
</span><span class="boring">       label: &amp;str,
</span><span class="boring">       admin: Option&lt;String&gt;,
</span><span class="boring">   ) -&gt; Result&lt;AdminContractProxy, ContractError&gt; {
</span><span class="boring">       let msg = InstantiateMsg {
</span><span class="boring">           admins,
</span><span class="boring">           donation_denom,
</span><span class="boring">       };
</span><span class="boring">
</span><span class="boring">       app.instantiate_contract(self.0, sender.clone(), &amp;msg, &amp;[], label, admin)
</span><span class="boring">           .map_err(|err| err.downcast().unwrap())
</span><span class="boring">           .map(AdminContractProxy)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Debug)]
<span class="boring">pub struct AdminContractProxy(Addr);
</span><span class="boring">
</span>impl AdminContractProxy {
<span class="boring">   pub fn addr(&amp;self) -&gt; &amp;Addr {
</span><span class="boring">       &amp;self.0
</span><span class="boring">   }
</span><span class="boring">   #[track_caller]
</span><span class="boring">   pub fn admin_list(&amp;self, app: &amp;App) -&gt; StdResult&lt;AdminListResp&gt; {
</span><span class="boring">       let msg = QueryMsg::AdminList {};
</span><span class="boring">
</span><span class="boring">       app.wrap().query_wasm_smart(self.0.clone(), &amp;msg)
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[track_caller]
</span><span class="boring">   pub fn add_member(
</span><span class="boring">       &amp;self,
</span><span class="boring">       app: &amp;mut App,
</span><span class="boring">       sender: &amp;Addr,
</span><span class="boring">       admin: String,
</span><span class="boring">   ) -&gt; Result&lt;AppResponse, ContractError&gt; {
</span><span class="boring">       let msg = ExecMsg::AddMember { admin };
</span><span class="boring">
</span><span class="boring">       app.execute_contract(sender.clone(), self.0.clone(), &amp;msg, &amp;[])
</span><span class="boring">           .map_err(|err| err.downcast().unwrap())
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[track_caller]
</span><span class="boring">   pub fn leave(&amp;self, app: &amp;mut App, sender: &amp;Addr) -&gt; Result&lt;AppResponse, ContractError&gt; {
</span><span class="boring">       let msg = ExecMsg::Leave {};
</span><span class="boring">
</span><span class="boring">       app.execute_contract(sender.clone(), self.0.clone(), &amp;msg, &amp;[])
</span><span class="boring">           .map_err(|err| err.downcast().unwrap())
</span><span class="boring">   }
</span><span class="boring">
</span>    #[track_caller]
    pub fn donate(
        &amp;self,
        app: &amp;mut App,
        sender: &amp;Addr,
        funds: &amp;[Coin],
    ) -&gt; Result&lt;AppResponse, ContractError&gt; {
        let msg = ExecMsg::Donate {};

        app.execute_contract(sender.clone(), self.0.clone(), &amp;msg, &amp;funds)
            .map_err(|err| err.downcast().unwrap())
    }
}
</code></pre>
<p>Now let' add donate test in <code>src/multitest/tests.rs</code></p>
<pre><code class="language-rust noplayground">use cosmwasm_std::{coins, Addr, Event};
use cw_multi_test::App;

use crate::error::ContractError;
use crate::{multitest::proxy::AdminContractCodeId, responses::AdminListResp};

const ATOM: &amp;str = &quot;atom&quot;;

<span class="boring">#[test]
</span><span class="boring">fn basic() {
</span><span class="boring">   let mut app = App::default();
</span><span class="boring">
</span><span class="boring">   let owner = Addr::unchecked(&quot;addr0001&quot;);
</span><span class="boring">   let admin1 = Addr::unchecked(&quot;admin1&quot;);
</span><span class="boring">   let admin2 = Addr::unchecked(&quot;admin2&quot;);
</span><span class="boring">   let admin3 = Addr::unchecked(&quot;admin3&quot;);
</span><span class="boring">
</span><span class="boring">   let code_id = AdminContractCodeId::store_code(&amp;mut app);
</span><span class="boring">
</span><span class="boring">   let contract = code_id
</span><span class="boring">       .instantiate(
</span><span class="boring">           &amp;mut app,
</span><span class="boring">           &amp;owner,
</span><span class="boring">           vec![admin1.to_string(), admin2.to_string()],
</span><span class="boring">           ATOM.to_string(),
</span><span class="boring">           &quot;Cw20 contract&quot;,
</span><span class="boring">           None,
</span><span class="boring">       )
</span><span class="boring">       .unwrap();
</span><span class="boring">
</span><span class="boring">   let resp = contract.admin_list(&amp;app).unwrap();
</span><span class="boring">
</span><span class="boring">   assert_eq!(
</span><span class="boring">       resp,
</span><span class="boring">       AdminListResp {
</span><span class="boring">           admins: vec![admin1.to_string(), admin2.to_string()]
</span><span class="boring">       }
</span><span class="boring">   );
</span><span class="boring">
</span><span class="boring">   let resp = contract
</span><span class="boring">       .add_member(&amp;mut app, &amp;admin1, admin3.to_string())
</span><span class="boring">       .unwrap();
</span><span class="boring">
</span><span class="boring">   let wasm = resp.events.iter().find(|ev| ev.ty == &quot;wasm&quot;).unwrap();
</span><span class="boring">   assert_eq!(
</span><span class="boring">       wasm.attributes
</span><span class="boring">           .iter()
</span><span class="boring">           .find(|attr| attr.key == &quot;action&quot;)
</span><span class="boring">           .unwrap()
</span><span class="boring">           .value,
</span><span class="boring">       &quot;add_member&quot;
</span><span class="boring">   );
</span><span class="boring">
</span><span class="boring">   let admin_added: Vec&lt;_&gt; = resp
</span><span class="boring">       .events
</span><span class="boring">       .iter()
</span><span class="boring">       .filter(|ev| ev.ty == &quot;wasm-admin_added&quot;)
</span><span class="boring">       .collect();
</span><span class="boring">   assert_eq!(
</span><span class="boring">       admin_added[0],
</span><span class="boring">       &amp;Event::new(&quot;wasm-admin_added&quot;)
</span><span class="boring">           .add_attribute(&quot;_contract_addr&quot;, contract.addr())
</span><span class="boring">           .add_attribute(&quot;addr&quot;, Addr::unchecked(&quot;admin3&quot;))
</span><span class="boring">   );
</span><span class="boring">
</span><span class="boring">   let resp = contract.admin_list(&amp;app).unwrap();
</span><span class="boring">
</span><span class="boring">   assert_eq!(
</span><span class="boring">       resp,
</span><span class="boring">       AdminListResp {
</span><span class="boring">           admins: vec![admin1.to_string(), admin2.to_string(), admin3.to_string()]
</span><span class="boring">       }
</span><span class="boring">   );
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn unathorized() {
</span><span class="boring">   let mut app = App::default();
</span><span class="boring">
</span><span class="boring">   let owner = Addr::unchecked(&quot;addr0001&quot;);
</span><span class="boring">   let admin1 = Addr::unchecked(&quot;admin1&quot;);
</span><span class="boring">   let admin2 = Addr::unchecked(&quot;admin2&quot;);
</span><span class="boring">   let admin3 = Addr::unchecked(&quot;admin3&quot;);
</span><span class="boring">
</span><span class="boring">   let code_id = AdminContractCodeId::store_code(&amp;mut app);
</span><span class="boring">
</span><span class="boring">   let contract = code_id
</span><span class="boring">       .instantiate(
</span><span class="boring">           &amp;mut app,
</span><span class="boring">           &amp;owner,
</span><span class="boring">           vec![admin1.to_string(), admin2.to_string()],
</span><span class="boring">           ATOM.to_string(),
</span><span class="boring">           &quot;Cw20 contract&quot;,
</span><span class="boring">           None,
</span><span class="boring">       )
</span><span class="boring">       .unwrap();
</span><span class="boring">
</span><span class="boring">   let resp = contract.admin_list(&amp;app).unwrap();
</span><span class="boring">
</span><span class="boring">   assert_eq!(
</span><span class="boring">       resp,
</span><span class="boring">       AdminListResp {
</span><span class="boring">           admins: vec![admin1.to_string(), admin2.to_string()]
</span><span class="boring">       }
</span><span class="boring">   );
</span><span class="boring">
</span><span class="boring">   let err = contract
</span><span class="boring">       .add_member(&amp;mut app, &amp;admin3, admin3.to_string())
</span><span class="boring">       .unwrap_err();
</span><span class="boring">
</span><span class="boring">   assert_eq!(err, ContractError::Unauthorized { sender: admin3 });
</span><span class="boring">
</span><span class="boring">   let resp = contract.admin_list(&amp;app).unwrap();
</span><span class="boring">
</span><span class="boring">   assert_eq!(
</span><span class="boring">       resp,
</span><span class="boring">       AdminListResp {
</span><span class="boring">           admins: vec![admin1.to_string(), admin2.to_string()]
</span><span class="boring">       }
</span><span class="boring">   );
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn leave() {
</span><span class="boring">   let mut app = App::default();
</span><span class="boring">
</span><span class="boring">   let owner = Addr::unchecked(&quot;addr0001&quot;);
</span><span class="boring">   let admin1 = Addr::unchecked(&quot;admin1&quot;);
</span><span class="boring">   let admin2 = Addr::unchecked(&quot;admin2&quot;);
</span><span class="boring">
</span><span class="boring">   let code_id = AdminContractCodeId::store_code(&amp;mut app);
</span><span class="boring">
</span><span class="boring">   let contract = code_id
</span><span class="boring">       .instantiate(
</span><span class="boring">           &amp;mut app,
</span><span class="boring">           &amp;owner,
</span><span class="boring">           vec![admin1.to_string(), admin2.to_string()],
</span><span class="boring">           ATOM.to_string(),
</span><span class="boring">           &quot;Cw20 contract&quot;,
</span><span class="boring">           None,
</span><span class="boring">       )
</span><span class="boring">       .unwrap();
</span><span class="boring">
</span><span class="boring">   let resp = contract.admin_list(&amp;app).unwrap();
</span><span class="boring">
</span><span class="boring">   assert_eq!(
</span><span class="boring">       resp,
</span><span class="boring">       AdminListResp {
</span><span class="boring">           admins: vec![admin1.to_string(), admin2.to_string()]
</span><span class="boring">       }
</span><span class="boring">   );
</span><span class="boring">
</span><span class="boring">   contract.leave(&amp;mut app, &amp;admin1).unwrap();
</span><span class="boring">
</span><span class="boring">   let resp = contract.admin_list(&amp;app).unwrap();
</span><span class="boring">
</span><span class="boring">   assert_eq!(
</span><span class="boring">       resp,
</span><span class="boring">       AdminListResp {
</span><span class="boring">           admins: vec![admin2.to_string()]
</span><span class="boring">       }
</span><span class="boring">   );
</span><span class="boring">}
</span><span class="boring">
</span>#[test]
fn donate() {
    let owner = Addr::unchecked(&quot;addr0001&quot;);
    let admin1 = Addr::unchecked(&quot;admin1&quot;);
    let admin2 = Addr::unchecked(&quot;admin2&quot;);

    let mut app = App::new(|router, _, storage| {
        router
            .bank
            .init_balance(storage, &amp;owner, coins(5, ATOM))
            .unwrap()
    });

    let code_id = AdminContractCodeId::store_code(&amp;mut app);

    let contract = code_id
        .instantiate(
            &amp;mut app,
            &amp;owner,
            vec![admin1.to_string(), admin2.to_string()],
            ATOM.to_string(),
            &quot;Cw20 contract&quot;,
            None,
        )
        .unwrap();

    contract.donate(&amp;mut app, &amp;owner, &amp;coins(5, ATOM)).unwrap();

    assert_eq!(
        app.wrap().query_balance(owner, ATOM).unwrap().amount.u128(),
        0
    );

    assert_eq!(
        app.wrap()
            .query_balance(contract.addr(), ATOM)
            .unwrap()
            .amount
            .u128(),
        1
    );

    assert_eq!(
        app.wrap()
            .query_balance(admin1, ATOM)
            .unwrap()
            .amount
            .u128(),
        2
    );

    assert_eq!(
        app.wrap()
            .query_balance(admin2, ATOM)
            .unwrap()
            .amount
            .u128(),
        2
    );
}
</code></pre>
<p>Fairly simple. I don't particularly appreciate that every balance check is eight lines of code,
but it can be improved by enclosing this assertion into a separate function, probably with the
<a href="https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-track_caller-attribute"><code>#[track_caller]</code></a> attribute.</p>
<p>The critical thing to talk about is how <code>app</code> creation changed. Because we need some initial tokens
on an <code>owner</code> account, instead of using the default constructor, we have to provide it with an
initializer function. Unfortunately,
<a href="https://docs.rs/cw-multi-test/latest/cw_multi_test/struct.App.html#method.new"><code>new</code></a> documentation
is not easy to follow - even if a function is not very complicated. What it takes as an argument is
a closure with three arguments - the
<a href="https://docs.rs/cw-multi-test/latest/cw_multi_test/struct.Router.html"><code>Router</code></a>
with all modules supported by multi-test, the API object, and the state. This function is called
once during contract instantiation. The <code>router</code> object contains some generic fields
- we are interested in the bank in particular. It has a type of
<a href="https://docs.rs/cw-multi-test/latest/cw_multi_test/struct.BankKeeper.html"><code>BankKeeper</code></a>,
where the
<a href="https://docs.rs/cw-multi-test/latest/cw_multi_test/struct.BankKeeper.html#method.init_balance"><code>init_balance</code></a>
function sits.</p>
<h2 id="plot-twist"><a class="header" href="#plot-twist">Plot Twist!</a></h2>
<p>As we covered most of the important basics about building Rust smart contracts, I have a serious
exercise for you.</p>
<p>The contract we built has an exploitable bug. All donations are distributed equally across admins.
However, every admin is eligible to add another admin. And nothing is preventing the admin from
adding himself to the list and receiving twice as many rewards as others!</p>
<p>Try to write a test that detects such a bug, then fix it and ensure the bug never more occurs.</p>
<p>Even if the admin cannot add the same address to the list, he can always create new accounts and
add them, but this is something unpreventable on the contract level, so do not prevent that.
Handling this kind of case is done by properly designing whole applications, which is out of this
chapter's scope.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="good-practices"><a class="header" href="#good-practices">Good practices</a></h1>
<p>All the relevant basics are covered. Now let's talk about some good practices.</p>
<h2 id="json-renaming"><a class="header" href="#json-renaming">JSON renaming</a></h2>
<p>Due to Rust style, all our message variants are spelled in a camel case. It is standard practice,
but it has a drawback - all messages are serialized and deserialized by the serde using those
variants names. The problem is that it is more common to use snake cases for field names in the
JSON world. Luckily there is an effortless way to tell the serde, to change the names casing for
serialization purposes. I mentioned it earlier when talking about query messages -
<code>#[serde(rename_all = &quot;snake_case&quot;)]</code>. Sylvia will automatically generate it for you in case of
messages. Unfortunately, in case of responses to your messages, you will have to do it by yourself.
Let's update our response with this attribute:</p>
<pre><code class="language-rust noplayground">use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Clone, PartialEq, Eq, schemars::JsonSchema, Debug, Default)]
#[serde(rename_all = &quot;snake_case&quot;)]
pub struct AdminListResp {
    pub admins: Vec&lt;String&gt;,
}
</code></pre>
<p>Looking at our <code>AdminListResp</code>, you might argue that all these derive look too clunky, and I agree.
Luckily the <a href="https://docs.rs/cosmwasm-schema/latest/cosmwasm_schema/index.html"><code>cosmwasm-schema</code></a>
create delivers <code>cw_serde</code> macro, which we can use to reduce a boilerplate:</p>
<pre><code class="language-rust noplayground">use cosmwasm_schema::cw_serde;

#[cw_serde]
pub struct AdminListResp {
    pub admins: Vec&lt;String&gt;,
}
</code></pre>
<h2 id="json-schema"><a class="header" href="#json-schema">JSON schema</a></h2>
<p>Talking about JSON API, it is worth mentioning JSON Schema. It is a way of defining the shape of
JSON messages. It is a good practice to provide a way to generate schemas for contract API.
The problem is that writing JSON schemas by hand is a pain. The good news is that there is a crate
that would help us with that. We have already used it before, and it is called
<a href="https://docs.rs/schemars/latest/schemars/"><code>schemars</code></a>. Sylvia will force you to add this
<code>derive</code> to your responses and will generate messages with it.</p>
<p>The only thing missing is new a <code>crate-type</code> in our <code>Cargo.toml</code>:</p>
<pre><code class="language-rust noplayground">[package]
name = &quot;contract&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[lib]
crate-type = [&quot;cdylib&quot;, &quot;rlib&quot;]

[features]
library = []

[dependencies]
cosmwasm-std = { version = &quot;1.1&quot;, features = [&quot;staking&quot;] }
cosmwasm-schema = &quot;1.1.6&quot;
serde = { version = &quot;1.0.147&quot;, features = [&quot;derive&quot;] }
sylvia = &quot;0.2.1&quot;
schemars = &quot;0.8.11&quot;
thiserror = &quot;1.0.37&quot;
cw-storage-plus = &quot;0.16.0&quot;
cw-utils = &quot;0.16&quot;

[dev-dependencies]
anyhow = &quot;1&quot;
cw-multi-test = &quot;0.16&quot;
</code></pre>
<p>I added <code>rlib</code>. <code>cdylib</code> crates cannot be used as typical Rust dependencies. As a consequence, it is
impossible to create examples for such crates.</p>
<p>The next step is to create a tool generating actual schemas. We will do it by creating a binary in
our crate. Create a new <code>bin/schema.rs</code> file:</p>
<pre><code class="language-rust noplayground">use contract::contract::{ContractExecMsg, ContractQueryMsg, InstantiateMsg};
use cosmwasm_schema::write_api;

fn main() {
    write_api! {
        instantiate: InstantiateMsg,
        execute: ContractExecMsg,
        query: ContractQueryMsg,
    }
}
</code></pre>
<p>Cargo is smart enough to recognize files in the <code>src/bin</code> directory as utility binaries for the crate.
Now we can generate our schemas:</p>
<pre><code class="language-bash">cargo run schema
   Finished dev [unoptimized + debuginfo] target(s) in 0.03s
     Running `target/debug/schema schema`
Exported the full API as /home/janw/workspace/confio/sylvia-book-contract/schema/contract.json
</code></pre>
<p>I encourage you to go to generated file to see what the schema looks like.</p>
<p>The problem is that unfortunately creating this binary makes our project fail to compile on the Wasm
target - which is the most important in the end. Hopefully, we don't need to build the schema
binary for the Wasm target - let's align the <code>.cargo/config</code> file:</p>
<pre><code class="language-rust noplayground">[alias]
wasm = &quot;build --target wasm32-unknown-unknown --release --lib&quot;
wasm-debug = &quot;build --target wasm32-unknown-unknown --lib&quot;
schema = &quot;run schema&quot;
</code></pre>
<p>The --lib flag added to wasm cargo aliases tells the toolchain to build only the library target - it
would skip building any binaries. Additionally, I added the convenience schema alias to
generate schema calling simply cargo schema.</p>
<p>If you are using <code>cw-utils</code> in version <code>1.0</code> <code>cargo wasm</code> command will still fail because of the
dependency to <a href="https://docs.rs/getrandom/latest/getrandom/#"><code>getrandom</code></a> crate. To fix the
<code>wasm</code> compilation, you have to add yet another dependency to our <code>Cargo.toml</code>:</p>
<pre><code class="language-rust noplayground">[package]
name = &quot;contract&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[lib]
crate-type = [&quot;cdylib&quot;, &quot;rlib&quot;]

[dependencies]
cosmwasm-std = { version = &quot;1.1&quot;, features = [&quot;staking&quot;] }
cosmwasm-schema = &quot;1.1.6&quot;
serde = { version = &quot;1.0.147&quot;, features = [&quot;derive&quot;] }
sylvia = &quot;0.2.1&quot;
schemars = &quot;0.8.11&quot;
cw-storage-plus = &quot;1.0&quot;
thiserror = &quot;1.0.37&quot;
cw-utils = &quot;1.0&quot;
getrandom = { version = &quot;0.2&quot;, features = [&quot;js&quot;] }

[dev-dependencies]
anyhow = &quot;1&quot;
cw-multi-test = &quot;0.16&quot;
</code></pre>
<p>With this last tweak, <code>cargo wasm</code> should compile correctly.</p>
<h2 id="disabling-entry-points-for-libraries"><a class="header" href="#disabling-entry-points-for-libraries">Disabling entry points for libraries</a></h2>
<p>Since we added the <code>rlib</code> target for the contract, it is, as mentioned before, usable as a
dependency. The problem is that the contract depending on ours, would have Wasm entry points
generated twice - once in the dependency and once in the final contract. We can work this around
by disabling generating Wasm entry points for the contract if the crate is used as a dependency.
We would use <a href="https://doc.rust-lang.org/cargo/reference/features.html"><code>feature flags</code></a> for that.</p>
<p>Start with updating <code>Cargo.toml</code>:</p>
<pre><code class="language-rust noplayground">[package]
name = &quot;contract&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[lib]
crate-type = [&quot;cdylib&quot;, &quot;rlib&quot;]

[features]
library = []

[dependencies]
cosmwasm-std = { version = &quot;1.1&quot;, features = [&quot;staking&quot;] }
cosmwasm-schema = &quot;1.1.6&quot;
serde = { version = &quot;1.0.147&quot;, features = [&quot;derive&quot;] }
sylvia = &quot;0.2.1&quot;
schemars = &quot;0.8.11&quot;
thiserror = &quot;1.0.37&quot;
cw-storage-plus = &quot;0.16.0&quot;
cw-utils = &quot;0.16&quot;
getrandom = { version = &quot;0.2&quot;, features = [&quot;js&quot;] }

[dev-dependencies]
anyhow = &quot;1&quot;
cw-multi-test = &quot;0.16&quot;
</code></pre>
<p>This way, we created a new feature flag for our crate. Now we want to disable the <code>entry_point</code>
attribute if our contract would be used as a dependency. We will do it by a slight update of
<code>src/lib.rs</code>:</p>
<pre><code class="language-rust noplayground">pub mod contract;
pub mod error;
pub mod responses;

#[cfg(test)]
mod multitest;

#[cfg(not(feature = &quot;library&quot;))]
mod entry_points {
    use cosmwasm_std::{entry_point, Binary, Deps, DepsMut, Env, MessageInfo, Response};

    use crate::contract::{AdminContract, ContractExecMsg, ContractQueryMsg, InstantiateMsg};
    use crate::error::ContractError;

    const CONTRACT: AdminContract = AdminContract::new();

    #[entry_point]
    pub fn instantiate(
        deps: DepsMut,
        env: Env,
        info: MessageInfo,
        msg: InstantiateMsg,
    ) -&gt; Result&lt;Response, ContractError&gt; {
        msg.dispatch(&amp;CONTRACT, (deps, env, info))
    }

    #[entry_point]
    pub fn query(deps: Deps, env: Env, msg: ContractQueryMsg) -&gt; Result&lt;Binary, ContractError&gt; {
        msg.dispatch(&amp;CONTRACT, (deps, env))
    }

    #[entry_point]
    pub fn execute(
        deps: DepsMut,
        env: Env,
        info: MessageInfo,
        msg: ContractExecMsg,
    ) -&gt; Result&lt;Response, ContractError&gt; {
        msg.dispatch(&amp;CONTRACT, (deps, env, info))
    }
}
</code></pre>
<p>The <a href="https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute"><code>cfg_attr</code></a>
is a conditional compilation attribute, similar to the <code>cfg</code> we used before for
the test. It expands to the given attribute if the condition expands to true. In our case - it would
expand to nothing if the feature &quot;library&quot; is enabled, or it would expand just to <code>#[entry_point]</code>
in another case.</p>
<p>Since now to add this contract as a dependency, don't forget to enable the feature like this:</p>
<pre><code class="language-rust noplayground">[dependencies]
my_contract = { version = &quot;0.1&quot;, features = [&quot;library&quot;] }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="floating-point-types"><a class="header" href="#floating-point-types">Floating point types</a></h1>
<p>Now you are ready to create smart contracts on your own. It is time to discuss an important
limitation of CosmWasm smart contracts - floating-point numbers.</p>
<p>The story is short: you cannot use floating-point types in smart contracts. Never. CosmWasm virtual
machine on purpose does not implement floating-point Wasm instructions, even such basics as
<code>F32Load</code>. The reasoning is simple: they are not safe to work with in the blockchain world.</p>
<p>The biggest problem is that contract will compile, but uploading it to the blockchain would fail
with an error message claiming there is a floating-point operation in the contract. A tool that
verifies if the contract is valid (it does not contain any fp operations but also has all needed
entry points and so on) is called <a href="https://crates.io/crates/cosmwasm-check"><code>cosmwasm-check</code></a>.</p>
<p>This limitation has two implications. First, you always have to use decimals of fixed-point
arithmetic in your contracts. It is not a problem, considering that <code>cosmwasm-std</code> provides you with
the <a href="https://docs.rs/cosmwasm-std/latest/cosmwasm_std/struct.Decimal.html"><code>Decimal</code></a> and
<a href="https://docs.rs/cosmwasm-std/latest/cosmwasm_std/struct.Decimal256.html"><code>Decimal256</code></a> types.</p>
<p>The other implication is tricky - you must be careful with the crates you use. In particular, one
gotcha in the <code>serde</code> crate - deserialization of usize type is using floating-point operations. That
means you can never use <code>usize</code> (or <code>isize</code>) types in your deserialized messages in the contract.</p>
<p>Another thing that will not work with serde is untagged enums deserialization. The workaround is to
create custom deserialization of such enums using
<a href="https://crates.io/crates/serde-cw-value"><code>serde-cw-value</code></a> crate. It is a fork of
<a href="https://crates.io/crates/serde-cw-value"><code>serde-value</code></a> crate which avoids generating
floating-point instructions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reusability"><a class="header" href="#reusability">Reusability</a></h1>
<p>We have covered almost everything needed to write CosmWasm smart contracts with <code>sylvia</code>.
In this last chapter of the <code>basics</code> section, I will tell you about the ability to define
<a href="https://docs.rs/sylvia/latest/sylvia/attr.interface.html"><code>interfaces</code></a> in <code>sylvia</code>.</p>
<h2 id="problem"><a class="header" href="#problem">Problem</a></h2>
<p>Let's say that after creating this contract we start working on another. While planning its
implementation, we notice that its functionality is just a superset of our <code>AdminContract</code>.
We could copy all the code to our new contract, but it's creating unnecessary redundancy and would
force us to maintain multiple implementations of the same functionality.</p>
<h2 id="solution"><a class="header" href="#solution">Solution</a></h2>
<p><code>Sylvia</code> has a feature to reuse already implemented messages and apply them in new contracts.
Clone and open <a href="https://github.com/CosmWasm/sylvia"><code>sylvia</code></a> repository. Go to
<code>contracts/cw1-subkeys/src/contract.rs</code>. You can notice that the <code>impl</code> block for
the <code>Cw1SubkeysContract</code> is preceded with <code>#[messages(...)]</code> attribute.</p>
<pre><code class="language-rust noplayground">#[contract]
#[messages(cw1 as Cw1)]
#[messages(whitelist as Whitelist)]
impl Cw1SubkeysContract&lt;'_&gt; {
    ...
}
</code></pre>
<p><code>contract</code> macro considers both interfaces marked as <code>messages</code>, which in our case
are <code>cw1</code> and <code>whitelist</code>. It then generates <code>ContractQueryMsg</code> and <code>ContractExecMsg</code> as such:</p>
<pre><code class="language-rust noplayground">#[allow(clippy::derive_partial_eq_without_eq)]
#[serde(rename_all = &quot;snake_case&quot;, untagged)]
pub enum ContractQueryMsg {
    Cw1(cw1::Cw1QueryMsg),
    Whitelist(whitelist::WhitelistQueryMsg),
    Cw1SubkeysContract(QueryMsg),
}

impl ContractQueryMsg {
    pub fn dispatch(
        self,
        contract: &amp;Cw1SubkeysContract,
        ctx: (cosmwasm_std::Deps, cosmwasm_std::Env),
    ) -&gt; std::result::Result&lt;sylvia::cw_std::Binary, ContractError&gt; {
        const _: () = {
            let msgs: [&amp;[&amp;str]; 3usize] = [
                &amp;cw1::Cw1QueryMsg::messages(),
                &amp;whitelist::WhitelistQueryMsg::messages(),
                &amp;QueryMsg::messages(),
            ];
            sylvia::utils::assert_no_intersection(msgs);
        };
        match self {
            ContractQueryMsg::Cw1(msg) =&gt; msg.dispatch(contract, ctx),
            ContractQueryMsg::Whitelist(msg) =&gt; msg.dispatch(contract, ctx),
            ContractQueryMsg::Cw1SubkeysContract(msg) =&gt; msg.dispatch(contract, ctx),
        }
    }
}
</code></pre>
<p>We can finally see why we need these <code>ContractQueryMsg</code> and <code>ContractExecMsg</code> next to our
regular message enums. <code>Sylvia</code> generated three tuple variants:</p>
<ul>
<li>
<p><code>Cw1</code> - which contains query msg defined in <code>whitelist</code>;</p>
</li>
<li>
<p><code>Whitelist</code>- which contains query msg defined in <code>cw1</code>;</p>
</li>
<li>
<p><code>Cw1SubkeysContract</code> - which contains query msg defined in our contract.</p>
</li>
</ul>
<p>We use this wrapper to match with the proper variant and then call <code>dispatch</code> on this message.
<code>Sylvia</code> also ensure that no message overlaps between interfaces and contract so that
contracts API won't break.</p>
<h2 id="declaring-interface"><a class="header" href="#declaring-interface">Declaring interface</a></h2>
<p>How are the <code>interface</code> messages implemented? <code>Cw1SubkeysContract</code> is an excellent example because
it presents two situations:</p>
<ul>
<li><code>Cw1</code> - declares a set of functionality that should be supported in implementing this interface
contract and forces the user to define behavior for them;</li>
<li><code>Whitelist</code> - same as above, but being primarily implemented for the <code>Cw1Whitelist</code> contract, it
has already implementation defined.</li>
</ul>
<p>For the latter one, we can either implement it ourselves or reuse it as it was done
in <code>contract/cw1-subkeys/src/whitelist.rs</code>. As you can see, we only call a method on <code>whitelist</code>
forwarding the arguments passed to the contract. To see the implementation,
you can go to <code>contract/cw1-whitelist/src/whitelist.rs</code>. The interface has to be defined as a
<code>trait</code> with a call to macro
<a href="https://docs.rs/sylvia/latest/sylvia/attr.interface.html"><code>interface</code></a>.
It currently supports only <code>execute</code> and <code>query</code> messages. In this case, it is right away
implemented on the <code>Cw1Whitelist</code> contract, and this implementation is being reused in
<code>contract/cw1-subkeys/src/whitelist.rs</code>.</p>
<p>You might also want to separate the functionalities of your contract in some sets. It is the case
of <code>Cw1</code>. It is created as a separate crate and reused in both <code>Cw1WhitelistContract</code> and
<code>Cw1SubkeysContract</code>. You can check the implementation in <code>contracts/cw1-subkeys/src/cw1.rs</code>.
For interface declaration itself, take a look at <code>contracts/cw1/src/lib.rs</code>.</p>
<h2 id="practice"><a class="header" href="#practice">Practice</a></h2>
<p>We now have enough background to create an <code>interface</code> ourselves. Let's say we started
working on some other contract and found out that the <code>donate</code> functionality would fit in it very
well. Open our <code>AdminContract</code> project. We will first create <code>src/donation.rs</code>:</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::{DepsMut, Env, MessageInfo, Response, StdError};
use sylvia::interface;

#[interface]
pub trait Donation {
    type Error: From&lt;StdError&gt;;

    #[msg(exec)]
    fn donate(&amp;self, ctx: (DepsMut, Env, MessageInfo)) -&gt; Result&lt;Response, Self::Error&gt;;
}
</code></pre>
<p>We add the <code>interface</code> attribute macro to the newly created <code>trait Donation</code>. If we stopped here, we
will get an error. <code>interface</code> forces us to alias Error for the trait. We will declare it as
<code>From&lt;StdError&gt;</code> as it is the error from cosmwasm_std, and we will always want our errors to
implement <code>From</code> on it. We then declare <code>donate</code> returning <code>Result</code> with
<code>Self::Error</code>, allowing users to define their error types.</p>
<p>Now that the declaration is ready, let's move the <code>donate</code> implementation to this file:</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::{coins, BankMsg, DepsMut, Env, MessageInfo, Order, Response, StdError};
use sylvia::interface;

use crate::{contract::AdminContract, error::ContractError};

#[interface]
pub trait Donation {
    type Error: From&lt;StdError&gt;;

    #[msg(exec)]
    fn donate(&amp;self, ctx: (DepsMut, Env, MessageInfo)) -&gt; Result&lt;Response, Self::Error&gt;;
}

impl Donation for AdminContract&lt;'_&gt; {
    type Error = ContractError;

    fn donate(&amp;self, ctx: (DepsMut, Env, MessageInfo)) -&gt; Result&lt;Response, ContractError&gt; {
        let (deps, _, info) = ctx;

        let denom = self.donation_denom.load(deps.storage)?;
        let admins_len = self
            .admins
            .keys(deps.storage, None, None, Order::Ascending)
            .filter_map(|admin| admin.ok())
            .count();

        let donation = cw_utils::must_pay(&amp;info, &amp;denom)
            .map_err(|err| StdError::generic_err(err.to_string()))?
            .u128();

        let donation_per_admin = donation / (admins_len as u128);

        let admins = self
            .admins
            .keys(deps.storage, None, None, Order::Ascending)
            .filter_map(|admin| admin.ok());

        let messages = admins.into_iter().map(|admin| BankMsg::Send {
            to_address: admin.to_string(),
            amount: coins(donation_per_admin, &amp;denom),
        });

        let resp = Response::new()
            .add_messages(messages)
            .add_attribute(&quot;action&quot;, &quot;donate&quot;)
            .add_attribute(&quot;amount&quot;, donation.to_string())
            .add_attribute(&quot;per_admin&quot;, donation_per_admin.to_string());

        Ok(resp)
    }
}
</code></pre>
<p>We alias <code>Error</code> as <code>ContractError</code> and move the whole method from <code>src/contract.rs</code>.
Now we only need to add the <code>Donation</code> interface to our contract:</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::{
    Addr, Deps, DepsMut, Empty, Env, Event, MessageInfo, Order, Response, StdResult,
};
use cw_storage_plus::{Item, Map};
use schemars;
use sylvia::contract;

use crate::{donation, error::ContractError, responses::AdminListResp};

<span class="boring">pub struct AdminContract&lt;'a&gt; {
</span><span class="boring">   pub(crate) admins: Map&lt;'a, &amp;'a Addr, Empty&gt;,
</span><span class="boring">   pub(crate) donation_denom: Item&lt;'a, String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>#[contract]
#[messages(donation as Donation)]
impl AdminContract&lt;'_&gt; {
    ...
<span class="boring">   pub const fn new() -&gt; Self {
</span><span class="boring">       AdminContract {
</span><span class="boring">           admins: Map::new(&quot;admins&quot;),
</span><span class="boring">           donation_denom: Item::new(&quot;donation_denom&quot;),
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[msg(instantiate)]
</span><span class="boring">   pub fn instantiate(
</span><span class="boring">       &amp;self,
</span><span class="boring">       ctx: (DepsMut, Env, MessageInfo),
</span><span class="boring">       admins: Vec&lt;String&gt;,
</span><span class="boring">       donation_denom: String,
</span><span class="boring">   ) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">       let (deps, _, _) = ctx;
</span><span class="boring">
</span><span class="boring">       for admin in admins {
</span><span class="boring">           let admin = deps.api.addr_validate(&amp;admin)?;
</span><span class="boring">           self.admins.save(deps.storage, &amp;admin, &amp;Empty {})?;
</span><span class="boring">       }
</span><span class="boring">       self.donation_denom.save(deps.storage, &amp;donation_denom)?;
</span><span class="boring">
</span><span class="boring">       Ok(Response::new())
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[msg(query)]
</span><span class="boring">   pub fn admin_list(&amp;self, ctx: (Deps, Env)) -&gt; StdResult&lt;AdminListResp&gt; {
</span><span class="boring">       let (deps, _) = ctx;
</span><span class="boring">
</span><span class="boring">       let admins: Result&lt;_, _&gt; = self
</span><span class="boring">           .admins
</span><span class="boring">           .keys(deps.storage, None, None, Order::Ascending)
</span><span class="boring">           .map(|addr| addr.map(String::from))
</span><span class="boring">           .collect();
</span><span class="boring">
</span><span class="boring">       Ok(AdminListResp { admins: admins? })
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[msg(exec)]
</span><span class="boring">   pub fn add_member(
</span><span class="boring">       &amp;self,
</span><span class="boring">       ctx: (DepsMut, Env, MessageInfo),
</span><span class="boring">       admin: String,
</span><span class="boring">   ) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">       let (deps, _, info) = ctx;
</span><span class="boring">
</span><span class="boring">       if !self.admins.has(deps.storage, &amp;info.sender) {
</span><span class="boring">           return Err(ContractError::Unauthorized {
</span><span class="boring">               sender: info.sender,
</span><span class="boring">           });
</span><span class="boring">       }
</span><span class="boring">       let admin = deps.api.addr_validate(&amp;admin)?;
</span><span class="boring">       self.admins.save(deps.storage, &amp;admin, &amp;Empty {})?;
</span><span class="boring">
</span><span class="boring">       let resp = Response::new()
</span><span class="boring">           .add_attribute(&quot;action&quot;, &quot;add_member&quot;)
</span><span class="boring">           .add_event(Event::new(&quot;admin_added&quot;).add_attribute(&quot;addr&quot;, admin));
</span><span class="boring">       Ok(resp)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">   use crate::entry_points::{execute, instantiate, query};
</span><span class="boring">   use cosmwasm_std::from_binary;
</span><span class="boring">   use cosmwasm_std::testing::{mock_dependencies, mock_env, mock_info};
</span><span class="boring">
</span><span class="boring">   use super::*;
</span><span class="boring">
</span><span class="boring">   #[test]
</span><span class="boring">   fn admin_list_query() {
</span><span class="boring">       let mut deps = mock_dependencies();
</span><span class="boring">       let env = mock_env();
</span><span class="boring">
</span><span class="boring">       instantiate(
</span><span class="boring">           deps.as_mut(),
</span><span class="boring">           env.clone(),
</span><span class="boring">           mock_info(&quot;sender&quot;, &amp;[]),
</span><span class="boring">           InstantiateMsg {
</span><span class="boring">               admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">               donation_denom: &quot;atom&quot;.to_owned(),
</span><span class="boring">           },
</span><span class="boring">       )
</span><span class="boring">       .unwrap();
</span><span class="boring">
</span><span class="boring">       let msg = QueryMsg::AdminList {};
</span><span class="boring">       let resp = query(deps.as_ref(), env, ContractQueryMsg::AdminContract(msg)).unwrap();
</span><span class="boring">       let resp: AdminListResp = from_binary(&amp;resp).unwrap();
</span><span class="boring">       assert_eq!(
</span><span class="boring">           resp,
</span><span class="boring">           AdminListResp {
</span><span class="boring">               admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">           }
</span><span class="boring">       );
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[test]
</span><span class="boring">   fn add_member() {
</span><span class="boring">       let mut deps = mock_dependencies();
</span><span class="boring">       let env = mock_env();
</span><span class="boring">
</span><span class="boring">       instantiate(
</span><span class="boring">           deps.as_mut(),
</span><span class="boring">           env.clone(),
</span><span class="boring">           mock_info(&quot;sender&quot;, &amp;[]),
</span><span class="boring">           InstantiateMsg {
</span><span class="boring">               admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">               donation_denom: &quot;atom&quot;.to_owned(),
</span><span class="boring">           },
</span><span class="boring">       )
</span><span class="boring">       .unwrap();
</span><span class="boring">
</span><span class="boring">       let info = mock_info(&quot;admin1&quot;, &amp;[]);
</span><span class="boring">       let msg = ExecMsg::AddMember {
</span><span class="boring">           admin: &quot;admin3&quot;.to_owned(),
</span><span class="boring">       };
</span><span class="boring">       execute(
</span><span class="boring">           deps.as_mut(),
</span><span class="boring">           env.clone(),
</span><span class="boring">           info,
</span><span class="boring">           ContractExecMsg::AdminContract(msg),
</span><span class="boring">       )
</span><span class="boring">       .unwrap();
</span><span class="boring">
</span><span class="boring">       let msg = QueryMsg::AdminList {};
</span><span class="boring">       let resp = query(deps.as_ref(), env, ContractQueryMsg::AdminContract(msg)).unwrap();
</span><span class="boring">       let resp: AdminListResp = from_binary(&amp;resp).unwrap();
</span><span class="boring">       assert_eq!(
</span><span class="boring">           resp,
</span><span class="boring">           AdminListResp {
</span><span class="boring">               admins: vec![
</span><span class="boring">                   &quot;admin1&quot;.to_owned(),
</span><span class="boring">                   &quot;admin2&quot;.to_owned(),
</span><span class="boring">                   &quot;admin3&quot;.to_owned()
</span><span class="boring">               ],
</span><span class="boring">           }
</span><span class="boring">       );
</span><span class="boring">   }
</span>}
</code></pre>
<p>Now you should have a compilation error while running tests. <code>src/multitest/proxy.rs</code> used
<code>ExecMsg::Donate {}</code>, but it is not a part of <code>ExecMsg</code> defined in <code>src/contract.rs</code>.
You can fix it f.e. by changing it to <code>let msg = crate::donation::ExecMsg::Donate {};</code> or you
can alias it in the <code>use</code> statement and use it as <code>DonateExecMsg::Donate {}</code>.</p>
<p>Now all tests should pass. You can run <code>cargo schema</code> to check what changed in your contract API.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="actor-model"><a class="header" href="#actor-model">Actor model</a></h1>
<p>This section describes the fundaments of CosmWasm smart contracts architecture, which determines how do they communicate
with each other. I want to go through this before teaching step by step how to create multiple contracts relating to each
other, to give you a grasp of what to expect. Don't worry if it will not be clear after the first read - I suggest going
through this chapter once now and maybe giving it another take in the future when you know the practical part of this.</p>
<p>The whole thing described here is officially documented in the
<a href="https://github.com/CosmWasm/cosmwasm/blob/main/SEMANTICS.md">SEMANTICS.md</a>, of the <code>cosmwasm</code> repository.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="idea-behind-an-actor-model"><a class="header" href="#idea-behind-an-actor-model">Idea behind an Actor Model</a></h1>
<p>The actor model is the solution to the problem of communication between smart
contracts. Let's take a look at the reasons why this particular solution is
chosen in CosmWasm, and what are the consequences of that.</p>
<h2 id="the-problem"><a class="header" href="#the-problem">The problem</a></h2>
<p>Smart contracts can be imagined as sandboxed microservices. Due to
<a href="https://en.wikipedia.org/wiki/SOLID">SOLID</a> principles, it is valuable to
split responsibilities between entities. However, to split the work between
contracts themselves, there is a need to communicate between them, so if one
contract is responsible for managing group membership, it is possible to call
its functionality from another contract.</p>
<p>The traditional way to solve this problem in SW engineering is to model
services as functions that would be called with some RPC mechanism, and return
its result as a response. Even though this approach looks nice, it creates sort
of problems, in particular with shared state consistency.</p>
<p>The other approach which is far more popular in business-level modeling is to
treat entities as actors, which can perform some tasks, but without
interrupting it with calls to other contracts. Any calls to other contracts can
only be called after the whole execution is performed. When &quot;subcall&quot; is
finished, it will call the original contract back.</p>
<p>This solution may feel unnatural, and it requires different kinds of design
solutions, but it turns out to work pretty well for smart contract execution.
I will try to explain how to reason about it, and how it maps to contract
structure step by step.</p>
<h2 id="the-actor"><a class="header" href="#the-actor">The Actor</a></h2>
<p>The most important thing in the whole model is an Actor itself. So, what is
this? The Actor is a single instantiation of a contract, which can perform
several actions. When the actor finishes his job, he prepares a summary of it,
which includes the list of things that have to be done, to complete the whole
scheduled task.</p>
<p>An example of an actor is the Seller in the KFC restaurant. The first thing you
do is order your BSmart, so you are requesting action from him. So, from the
system user, you can think about this task as &quot;sell and prepare my meal&quot;, but
the action performed by the seller is just &quot;Charge payment and create order&quot;.
The first part of this operation is to create a bill and charge you for it, and
then it requests the Sandwich and Fries to be prepared by other actors,
probably chefs. Then when the chef is done with his part of the meal, he checks
if all meals are ready. If so, it calls the last actor, the waiter, to deliver
the food to you. At this point, you can receive your delivery, and the task is
considered complete.</p>
<p>The above-described workflow is kind of simplified. In particular - in a
typical restaurant, a waiter would observe the kitchen instead of being
triggered by a chef, but in the Actor model, it is not possible. Here, entities
of the system are passive and cannot observe the environment actively - they
only react to messages from other system participants. Also in KFC, the seller
would not schedule subtasks for particular chefs; instead, he would leave tasks
to be taken by them, when they are free. It is not the case, because as before -
chefs cannot actively listen to the environment. However, it would be possible
to create a contract for being a chef's dispatcher which would collect all
orders from sellers, and balance them across chefs for some reason.</p>
<h2 id="the-action"><a class="header" href="#the-action">The Action</a></h2>
<p>Actors are the model entities, but to properly communicate with them, we need
some kind of protocol. Every actor is capable of performing several actions. In
my previous KFC example, the only action seller can do is &quot;Charge payment and
create order&quot;. However, it is not always the case - our chefs were proficient
at performing both &quot;Prepare fries&quot; and &quot;Prepare Sandwich&quot; actions - and also
many more.</p>
<p>So, when we want to do something in an actor system, we schedule some action to
the actor being the closest to us, very often with some additional parameters
(as we can pick if we want to exchange fries with salad).</p>
<p>However, naming the action after the exact thing which happened in the very
contract would be misleading. Take a look at the KFC example once again. As I
mentioned, the action performed by a seller is &quot;Charge payment and create
order&quot;. The problem is, that for the client who schedules this action, it
doesn't matter what exactly is the responsibility of the actor himself - what
the client is scheduling is &quot;Prepare Meal&quot; with some description of what
exactly to prepare. So, we can say, that the action is the thing performed by
the contract itself, plus all the sub-actions it schedules.</p>
<h2 id="multi-stage-actions"><a class="header" href="#multi-stage-actions">Multi-stage Actions</a></h2>
<p>So as the whole idea makes some sense, there is the problem created by the
actor model: what if I want to perform some action in my contract, but to
completely finalize some steps, the contract has to make sure that some
sub-action he scheduled are finished?</p>
<p>Imagine that in the previous KFC situation, there is no dedicated Waiter.
Instead the Seller was serving you a meal when the Chefs finished their job.</p>
<p>This kind of pattern is so important and common that in CosmWasm, we developed
a special way to handle it, which is dedicated <code>Reply</code> action.</p>
<p>So when Seller is scheduling actions for chefs, he assigns some number to this
action (like order id) and passes it to chefs. He also remembers how many
actions he scheduled for every order id. Now every time chef is finished with
his action; he would call the special <code>Reply</code> action on Seller, in which he
would pass back the order id. Then, Seller would decrease the number of actions
left for this order, and if it reached zero, he would serve a meal.</p>
<p>Now you can say, that the <code>Reply</code> action is completely not needed, as Chefs
could just schedule any arbitrary action on Seller, like <code>Serve</code>, why is there
the special <code>Reply</code> for? The reason is abstraction and reusability. The Chefs
task is to prepare a meal, and that is all. There is no reason for him to know
why he is even preparing Fries - if it is part of the bigger task (like order
for a client), or the seller is just hungry. It is possible that not only the
seller is eligible to call the chef for food - possibly any restaurant employee
can do that just for themselves. Therefore, we need a way to be able to react
to an actor finishing his job in some universal way, to handle this situation
properly in any context.</p>
<p>It is worth noting that the <code>Reply</code> can contain some additional data. The id
assigned previously is the only required information in the <code>Reply</code> call, but
the actor can pass some additional data - <code>events</code> emitted, which are mostly
metadata (to be observed by non-blockchain applications mostly), and any
arbitrary data it wants to pass.</p>
<h2 id="state"><a class="header" href="#state">State</a></h2>
<p>Up until this point, we were considering actors as entities performing some
job, like preparing the meal. If we are considering computer programs, such a
job would be to show something on the screen, maybe print something. This is
not the case with Smart Contracts. The only thing which can be affected by the
Smart Contract is their internal state. So, the state is arbitrary data that is
kept by the contract. Previously in the KFC example I mentioned, the Seller is
keeping in mind how many actions he scheduled for chefs are not yet finished -
this number is part of the Seller's state.</p>
<p>To give a more realistic example of a contract state, let's think about a more
real-life Smart Contract than the restaurant. Let's imagine we want to create
our currency - maybe we want to create some smart contracts-based market for
some MMORPG game. So, we need some way to be able to at least transfer currency
between players. We can do that, by creating the contract we would call
<code>MmoCurrency</code>, which would support the <code>Transfer</code> action to transfer money to
another player. Then what would be the state of such a contract? It would be
just a table mapping player names to the amount of currency they own. The
contract we just invited exists in CosmWasm examples, and it is called the
<a href="https://github.com/CosmWasm/cw-plus/tree/main/contracts/cw20-base"><code>cw20-base</code>
contract</a>
(it is a bit more complicated, but it is its core idea).</p>
<p>And now there is a question - how is this helpful to transfer currency if I
cannot check how much of it do I own? It is a very good question, and the
answer to that is simple - the whole state of every contract in our system is
public. It is not universal for every Actor model, but it is how it works in
CosmWasm, and it is kind of forced by the nature of blockchain. Everything
happening in blockchain has to be public, and if some information should be
hidden, it has to be stored indirectly.</p>
<p>There is one very important thing about the state in CosmWasm, and it is the
state being transactional. Any updates to the state are not applied
immediately, but only when the whole action succeeds. It is very important, as
it guarantees that if something goes wrong in the contract, it is always left
in some proper state. Let's consider our <code>MmoCurrency</code> case. Imagine, that in
the <code>Transfer</code> action we first increase the receiver currency amount (by
updating the state), and only then do we decrease the sender amount. However,
before decreasing it, we need to check if a sender possesses enough funds to
perform the transaction. In case we realize that we cannot do it, we don't need
to do any rolling back by hand - we would just return a failure from the action
execution, and the state would not be updated. So, when in the contract state
is updated, it is just a local copy of this state being altered, but the
partial changes would never be visible by other contracts.</p>
<h2 id="queries"><a class="header" href="#queries">Queries</a></h2>
<p>There is one building block in the CosmWasm approach to the Actor model, which
I haven't yet cover. As I said, the whole state of every contract is public and
available for everyone to look at. The problem is that this way of looking at
state is not very convenient - it requires users of contracts to know its
internal structure, which kind of violates the SOLID rules (Liskov substitution
principle in particular). If, for example a contract is updated and its state
structure changes a bit, another contract looking at its state would just
nevermore work. Also, it is often the case, that the contract state is kind of
simplified, and information that is relevant to the observer would be
calculated from the state.</p>
<p>This is where queries come into play. Queries are the type of messages to
contract, which does not perform any actions, so do not update any state, but
can return an answer immediately.</p>
<p>In our KFC comparison, the query would be if Seller goes to Chef to ask &quot;Do we
still have pickles available for our cheeseburgers&quot;? It can be done while
operating, and response can be used in it. It is possible because queries can
never update their state, so they do not need to be handled in a transactional
manner.</p>
<p>However, the existence of queries doesn't mean that we cannot look at the
contract's state directly - the state is still public, and the technique of
looking at them directly is called <code>Raw Queries</code>. For clarity, non-raw queries
are sometimes denoted as <code>Smart Queries</code>.</p>
<h2 id="wrapping-everything-together---transactional-call-flow"><a class="header" href="#wrapping-everything-together---transactional-call-flow">Wrapping everything together - transactional call flow</a></h2>
<p>So, we touched on many things here, and I know it may be kind of confusing.
Because of that, I would like to go through some more complicated calls to the
CosmWasm contract to visualize what the &quot;transactional state&quot; means.</p>
<p>Let's imagine two contracts:</p>
<ol>
<li>The <code>MmoCurrency</code> contract mentioned before, which can perform the
<code>Transfer</code> action, allows transferring some <code>amount</code> of currency to some
<code>receiver</code>.</li>
<li>The <code>WarriorNpc</code> contract, which would have some amount of our currency, and
he would be used by our MMO engine to pay the reward out for some quest
player could perform. It would be triggered by <code>Payout</code> action, which can be
called only by a specific client (which would be our game engine).</li>
</ol>
<p>Now here is an interesting thing - this model forces us to make our MMO more
realistic in terms of the economy that we traditionally see - it is because
<code>WarriorNpc</code> has some amount of currency, and cannot create more out of
anything. It is not always the case (the previously mentioned <code>cw20</code> has a
notion of Minting for this case), but for the sake of simplicity let's assume this
is what we want.</p>
<p>To make the quest reasonable for longer, we would make a reward for it to be
always between <code>1 mmo</code> and <code>100 mmo</code>, but it would be ideally <code>15%</code> of what
Warrior owns. This means that the quest reward decreases for every subsequent
player, until Warrior would be broke, left with nothing, and will no longer be
able to payout players.</p>
<p>So, what would the flow look like? The first game would send a <code>Payout</code> message
to the <code>WarriorNpc</code> contract, with info on who should get the reward. Warrior
would keep track of players who fulfilled the quest, to not pay out the same
person twice - there would be a list of players in his state. First, he would
check the list looking for players to pay out - if he is there, he will finish
the transaction with an error.</p>
<p>However, in most cases the player would not be on the list - so then
<code>WarriorNpc</code> would add him to the list. Now the Warrior would finish his part
of the task, and schedule the <code>Transfer</code> action to be performed by
<code>MmoCurrency</code>.</p>
<p>But there is the important thing - because <code>Transfer</code> action is actually part
of the bigger <code>Payout</code> flow, it would not be executed on the original
blockchain state, but on the local copy of it, to which the player's list is
already applied to. So if the <code>MmoCurrency</code> would for any reason takes a look
at <code>WarriorNpc</code> internal list, it would be already updated.</p>
<p>Now <code>MmoCurrency</code> is doing its job, updating the state of Warrior and player
balance (note, that our Warrior is here just treated as another player!). When
it finishes, two things may happen:</p>
<ol>
<li>There was an error - possibly Warrior is out of cash, and it can nevermore
pay for the task. In such case, none of the changes - neither updating the
list of players succeeding, nor balance changes are not applied to the
original blockchain storage, so they are like they never happened. In the
database world, it is denoted as rolling back the transaction.</li>
<li>Operation succeed - all changes on the state are now applied to the
blockchain, and any further observation of <code>MmoCurrency</code> or <code>WarriorNpc</code> by
the external world would see updated data.</li>
</ol>
<p>There is one problem - in this model, our list is not a list of players who
fulfilled the quest (as we wanted it to be), but the list of players who paid
out (as in transfer failure, the list is not updated). We can do better.</p>
<h2 id="different-ways-of-handling-responses"><a class="header" href="#different-ways-of-handling-responses">Different ways of handling responses</a></h2>
<p>Note that we didn't mention a <code>Reply</code> operation at all. So why was it not
called by <code>MmoCurrency</code> on <code>WarriorNpc</code>? The reason is that this operation is
optional. When scheduling sub-actions on another contract we may choose when
<code>Reply</code> how the result should be handled:</p>
<ol>
<li>Never call <code>Reply</code>, action fails if sub-message fails</li>
<li>Call <code>Reply</code> on success</li>
<li>Call <code>Reply</code> on failure</li>
<li>Always call <code>Reply</code></li>
</ol>
<p>So, if we do not request <code>Reply</code> to be called by subsequent contract, it will
not happen. In such a case if a sub-call fails, the whole transaction is rolled
back - sub-message failure transitively causes the original message failure. It
is probably a bit complicated for now, but I promise it would be simple if you
would did some practice with that.</p>
<p>When handling the reply, it is important to remember, that although changes are
not yet applied to the blockchain (the transaction still can be failed), the
reply handler is already working on the copy of the state with all changes made
by sub-message so far applied. In most cases, it would be a good thing, but it
has a tricky consequence - if the contract is calling itself recursively, it is
possible that subsequent call overwrote things set up in the original message.
It rarely happens, but may need special treatment in some cases - for now I
don't want to go deeply into details, but I want you to remember about what to
expect after state in the actor's flow.</p>
<p>Now let's take a look at handling results with <code>2</code>-<code>4</code> options. It is actually
interesting, that using <code>2</code>, even if the transaction is performed by sub-call
succeed, we may now take a look at the data it returned with <code>Reply</code>, and on
its final state after it finished, and we can still decide, that act as a
whole is a failure, in which case everything would be rolled back - even
currency transfer performed by external contract.</p>
<p>In our case, an interesting option is <code>3</code>. So, if the contract would call
<code>Reply</code> on failure, we can decide to claim success, and commit a transaction on
the state if the sub call failed. Why may it be relevant for us? Possibly
because our internal list was supposed to keep the list of players succeeding
with the quest, not paid out! So, if we have no more currency, we still want to
update the list!</p>
<p>The most common way to use the replies (option <code>2</code> in particular)  is to
instantiate another contract, managed by the one called. The idea is that in
those use cases, the creator contract wants to keep the address of the created
contract in its state. To do so it has to create an <code>Instantiate</code> sub-message,
and subscribe for its success response, which contains the address of the freshly
created contract.</p>
<p>In the end, you can see that performing actions in CosmWasm is built with
hierarchical state change transactions. The sub-transaction can be applied to
the blockchain only if everything succeeds, but in case that sub-transaction
failed, only its part may be rolled back, end other changes may be applied. It
is very similar to how most database systems work.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Now you have seen the power of the actor model to avoid reentrancy, properly
handle errors, and safely sandbox contracts. This helps us provide the solid
security guarantees of the CosmWasm platform. Lets get started playing around
with real contracts in the <code>wasmd</code> blockchain.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="actors-in-blockchain"><a class="header" href="#actors-in-blockchain">Actors in blockchain</a></h1>
<p>Previously we were talking about actors mostly in the abstraction of any
blockchain-specific terms. However, before we would dive into the code, we need
to establish some common language, and to do so we would look at contracts from
the perspective of external users, instead of their implementation.</p>
<p>In this part, I would use the <code>wasmd</code> binary to communicate with the malaga
testnet. To properly set it up, check the <a href="actor-model/../wasmd-quick-start.html">Quick start with
<code>wasmd</code></a>.</p>
<h2 id="blockchain-as-a-database"><a class="header" href="#blockchain-as-a-database">Blockchain as a database</a></h2>
<p>It is kind of starting from the end, but I would start with the state part of
the actor model. Relating to traditional systems, there is one particular thing
I like to compare blockchain with - it is a database.</p>
<p>Going back to the previous section we learned that the most important part of
a contract is its state. Manipulating the state is the only way to persistently
manifest work performed to the world. But What is the thing which purpose is to
keep the state? It is a database!</p>
<p>So here is my (as a contract developer) point of view on contracts: it is a distributed
database, with some magical mechanisms to make it democratic. Those &quot;magical
mechanisms&quot; are crucial for BC's existence and they make they are reasons why even
use blockchain, but they are not relevant from the contract creator's point of
view - for us, everything that matters is the state.</p>
<p>But you can say: what about the financial part?! Isn't blockchain (<code>wasmd</code> in particular)
the currency implementation? With all of those gas costs, sending funds seems
very much like a money transfer, not database updates. And yes, you are kind of right,
but I have a solution for that too. Just imagine, that for every native token (by
&quot;native tokens&quot; we meant tokens handled directly by blockchain, in contradiction
to for example cw20 tokens) there is a special database bucket (or table if you prefer)
with mapping of address to how much of a token the address possesses. You can query
this table (querying for token balance), but you cannot modify it directly. To modify
it you just send a message to a special build-in bank contract. And everything
is still a database.</p>
<p>But if blockchain is a database, then where are smart contracts stored?
Obviously - in the database itself! So now imagine another special table - this
one would contain a single table of code-ids mapped to blobs of wasm binaries. And
again - to operate on this table, you use &quot;special contract&quot; which is not accessible
from another contract, but you can use it via <code>wasmd</code> binary.</p>
<p>Now there is a question - why do I even care about BC being a DB? So the reason
is that it makes reasoning about everything in blockchain very natural. Do you
remember that every message in the actor model is transactional? It perfectly
matches traditional database transactions (meaning: every message starts a new
transaction)! Also, when we later talk about migrations, it would turn out, that
migrations in CosmWasm are very much equivalents of schema migrations in
traditional databases.</p>
<p>So, the thing to remember - blockchain is very similar to a database, having some
specially reserved tables (like native tokens, code repository), with a special
bucket created for every contract. A contract can look at every table in every
bucket in the whole blockchain, but it can modify the only one he created.</p>
<h2 id="compile-the-contract"><a class="header" href="#compile-the-contract">Compile the contract</a></h2>
<p>I will not go into the code for now, but to start with something we need compiled
contract binary. The <code>cw4-group</code> contract from
<a href="https://github.com/CosmWasm/cw-plus">cw-plus</a> is simple enough to work with, for
now, so we will start with compiling it. Start with cloning the repository:</p>
<pre><code class="language-bash">$ git clone git@github.com:CosmWasm/cw-plus.git
</code></pre>
<p>Then go to <code>cw4-group</code> contract and build it:</p>
<pre><code class="language-bash">$ cd cw-plus/contracts/cw4-group
$ docker run --rm -v &quot;$(pwd)&quot;:/code \
  --mount type=volume,source=&quot;$(basename &quot;$(pwd)&quot;)_cache&quot;,target=/code/target \
  --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \
  cosmwasm/workspace-optimizer:0.12.6
</code></pre>
<p>Your final binary should be located in the
<code>cw-plus/artifacts</code> folder (<code>cw-plus</code> being where you cloned your repository).</p>
<h2 id="contract-code"><a class="header" href="#contract-code">Contract code</a></h2>
<p>When the contract binary is built, the first interaction with CosmWasm is uploading
it to the blockchain (assuming you have your wasm binary in the working directory):</p>
<pre><code class="language-bash">$ wasmd tx wasm store ./cw4-group.wasm --from wallet $TXFLAG -y -b block
</code></pre>
<p>As a result of such an operation you would get json output like this:</p>
<pre><code>..
logs:
..
- events:
  ..
  - attributes:
    - key: code_id
      value: &quot;1069&quot;
    type: store_code
</code></pre>
<p>I ignored most of not fields as they are not relevant for now - what we care
about is the event emitted by blockchain with information about <code>code_id</code> of
stored contract - in my case the contract code was stored in blockchain under
the id of <code>1069</code>. I can now look at the code by querying for it:</p>
<pre><code class="language-bash">$ wasmd query wasm code 1069 code.wasm
</code></pre>
<p>And now the important thing - the contract code is not an actor. So, what is a
contract code? I think that the easiest way to think about that is a <code>class</code> or
a <code>type</code> in programming. It defines some stuff about what can be done, but the
class itself is in most cases not very useful unless we create an instance
of a type, on which we can call class methods. So now let's move forward to
instances of such contract classes.</p>
<h2 id="contract-instance"><a class="header" href="#contract-instance">Contract instance</a></h2>
<p>Now we have a contract code, but what we want is an actual contract itself.
To create it, we need to instantiate it. Relating to analogy to programming,
instantiation is calling a constructor. To do that, I would send an
instantiate message to my contract:</p>
<pre><code class="language-bash">$ wasmd tx wasm instantiate 1069 '{&quot;members&quot;: []}' --from wallet --label &quot;Group 1&quot; --no-admin $TXFLAG -y
</code></pre>
<p>What I do here is create a new contract and immediately call the <code>Instantiate</code>
message on it. The structure of such a message is different for every contract
code. In particular, the <code>cw4-group</code> Instantiate message contains two fields:</p>
<ul>
<li><code>members</code> field which is the list of initial group members optional <code>admin</code></li>
<li>field which defines an address of who can add or remove
a group member</li>
</ul>
<p>In this case, I created an empty group with no admin - so which could never
change! It may seem like a not very useful contract, but it serves us as a
contract example.</p>
<p>As the result of instantiating, I got the result:</p>
<pre><code>..
logs:
..
- events:
  ..
  - attributes:
    - key: _contract_address
      value: wasm1u0grxl65reu6spujnf20ngcpz3jvjfsp5rs7lkavud3rhppnyhmqqnkcx6
    - key: code_id
      value: &quot;1069&quot;
    type: instantiate
</code></pre>
<p>As you can see, we again look at <code>logs[].events[]</code> field, looking for
interesting event and extracting information from it - it is the common case.
I will talk about events and their attributes in the future but in general,
it is a way to notify the world that something happened. Do you remember the
KFC example? If a waiter is serving our dish, he would put a tray on the bar,
and she would yell (or put on the screen) the order number - this would be
announcing an event, so you know some summary of operation, so you can go and
do something useful with it.</p>
<p>So, what use can we do with the contract? We obviously can call it! But first
I want to tell you about addresses.</p>
<h2 id="addresses-in-cosmwasm"><a class="header" href="#addresses-in-cosmwasm">Addresses in CosmWasm</a></h2>
<p>Address in CosmWasm is a way to refer to entities in the blockchain. There are
two types of addresses: contract addresses, and non-contracts. The difference
is that you can send messages to contract addresses, as there is some smart
contract code associated with them, and non-contracts are just users of the
system. In an actor model, contract addresses represent actors, and
non-contracts represent clients of the system.</p>
<p>When operating with blockchain using <code>wasmd</code>, you also have an address - you
got one when you added the key to <code>wasmd</code>:</p>
<pre><code class="language-bash"># add wallets for testing
$ wasmd keys add wallet3
- name: wallet3
  type: local
  address: wasm1dk6sq0786m6ayg9kd0ylgugykxe0n6h0ts7d8t
  pubkey: '{&quot;@type&quot;:&quot;/cosmos.crypto.secp256k1.PubKey&quot;,&quot;key&quot;:&quot;Ap5zuScYVRr5Clz7QLzu0CJNTg07+7GdAAh3uwgdig2X&quot;}'
  mnemonic: &quot;&quot;
</code></pre>
<p>You can always check your address:</p>
<pre><code class="language-bash">$ wasmd keys show wallet
- name: wallet
  type: local
  address: wasm1um59mldkdj8ayl5gknp9pnrdlw33v40sh5l4nx
  pubkey: '{&quot;@type&quot;:&quot;/cosmos.crypto.secp256k1.PubKey&quot;,&quot;key&quot;:&quot;A5bBdhYS/4qouAfLUH9h9+ndRJKvK0co31w4lS4p5cTE&quot;}'
  mnemonic: &quot;&quot;
</code></pre>
<p>Having an address is very important because it is a requirement for being able
to call anything. When we send a message to a contract it always knows the
address which sends this message so it can identify it - not to mention that
this sender is an address that would play a gas cost.</p>
<h2 id="querying-the-contract"><a class="header" href="#querying-the-contract">Querying the contract</a></h2>
<p>So, we have our contract, let's try to do something with it - query would be the
easiest thing to do. Let's do it:</p>
<pre><code class="language-bash">$ wasmd query wasm contract-state smart wasm1u0grxl65reu6spujnf20ngcpz3jvjfsp5rs7lkavud3rhppnyhmqqnkcx6 '{ &quot;list_members&quot;: {} }'
data:
  members: []
</code></pre>
<p>The <code>wasm...</code> string is the contract address, and you have to substitute it with
your contract address. <code>{ &quot;list_members&quot;: {} }</code> is query message we send to
contract. Typically, CW smart contract queries are in the form of a single JSON
object, with one field: the query name (<code>list_members</code> in our case). The value
of this field is another object, being query parameters - if there are any.
<code>list_members</code> query handles two parameters: <code>limit</code>, and <code>start_after</code>, which
are both optional and which support result pagination. However, in our case of
an empty group they don't matter.</p>
<p>The query result we got is in human-readable text form (if we want to get the
JSON from - for example, to process it further with <code>jq</code>, just pass the
<code>-o json</code> flag). As you can see response contains one field: <code>members</code> which is
an empty array.</p>
<p>So, can we do anything more with this contract? Not much. But let's try to do
something with a new one!</p>
<h2 id="executions-to-perform-some-actions"><a class="header" href="#executions-to-perform-some-actions">Executions to perform some actions</a></h2>
<p>The problem with our previous contract is that for the <code>cw4-group</code> contract,
the only one who can perform executions on it is an admin, but our contract
doesn't have one. This is not true for every smart contract, but it is the
nature of this one.</p>
<p>So, let's make a new group contract, but this time we would
make ourselves an admin. First, check our wallet address:</p>
<pre><code class="language-bash">$ wasmd keys show wallet
</code></pre>
<p>And instantiate a new group contract - this time with proper admin:</p>
<pre><code class="language-bash">$ wasmd tx wasm instantiate 1069 '{&quot;members&quot;: [], &quot;admin&quot;: &quot;wasm1um59mldkdj8ayl5gknp9pnrdlw33v40sh5l4nx&quot;}' --from wallet --label &quot;Group 1&quot; --no-admin $TXFLAG -y
..
logs:
- events:
  ..
  - attributes:
    - key: _contract_address
      value: wasm1n5x8hmstlzdzy5jxd70273tuptr4zsclrwx0nsqv7qns5gm4vraqeam24u
    - key: code_id
      value: &quot;1069&quot;
    type: instantiate
</code></pre>
<p>You may ask, why do we pass some kind of <code>--no-admin</code> flag, if we just said, we
want to set an admin to the contract? The answer is sad and confusing, but...
it is a different admin. The admin we want to set is one checked by the
contract itself and managed by him. The admin which is declined with
<code>--no-admin</code> flag, is a wasmd-level admin, which can migrate the contract. You
don't need to worry about the second one at least until you learn about
contract migrations - until then you can always pass the <code>--no-admin</code> flag to
the contract.</p>
<p>Now let's query our new contract for the member's list:</p>
<pre><code class="language-bash">$ wasmd query wasm contract-state smart wasm1n5x8hmstlzdzy5jxd70273tuptr4zsclrwx0nsqv7qns5gm4vraqeam24u '{ &quot;list_members&quot;: {} }'
data:
  members: []
</code></pre>
<p>Just like before - no members initially. Now check an admin:</p>
<pre><code>$ wasmd query wasm contract-state smart wasm1n5x8hmstlzdzy5jxd70273tuptr4zsclrwx0nsqv7qns5gm4vraqeam24u '{ &quot;admin&quot;: {} }'
data:
  admin: wasm1um59mldkdj8ayl5gknp9pnrdlw33v40sh5l4nx
</code></pre>
<p>So, there is an admin, it seems like the one we wanted to have there. So now we
would add someone to the group - maybe ourselves?</p>
<pre><code class="language-bash">wasmd tx wasm execute wasm1n5x8hmstlzdzy5jxd70273tuptr4zsclrwx0nsqv7qns5gm4vraqeam24u '{ &quot;update_members&quot;: { &quot;add&quot;: [{ &quot;addr&quot;: &quot;wasm1um59mldkdj8ayl5gkn
p9pnrdlw33v40sh5l4nx&quot;, &quot;weight&quot;: 1 }], &quot;remove&quot;: [] } }' --from wallet $TXFLAG -y
</code></pre>
<p>The message for modifying the members is <code>update_members</code> and it has two
fields: members to remove, and members to add. Members to remove are
just addresses. Members to add have a bit more complex structure: they
are records with two fields: address and weight. Weight is not relevant
for us now, it is just metadata stored with every group member - for
us, it would always be 1.</p>
<p>Let's query the contract again to check if our message changed anything:</p>
<pre><code class="language-bash">$ wasmd query wasm contract-state smart wasm1n5x8hmstlzdzy5jxd70273tuptr4zsclrwx0nsqv7qns5gm4vraqeam24u '{ &quot;list_members&quot;: {} }'
data:
  members:
  - addr: wasm1um59mldkdj8ayl5gknp9pnrdlw33v40sh5l4nx
    weight: 1
</code></pre>
<p>As you can see, the contract updated its state. This is basically how
it works - sending messages to contracts causes them to update the state,
and the state can be queried at any time. For now, to keep things simple
we were just interacting with the contract directly by <code>wasmd</code>, but as described
before - contracts can communicate with each other. However, to investigate
this we need to understand how to write contracts. Next time we will look
at the contract structure and we will map it part by part to what we have learned
until now.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smart-contract-as-an-actor"><a class="header" href="#smart-contract-as-an-actor">Smart contract as an actor</a></h1>
<p>In previous chapters, we talked about the actor model and how it is implemented
in the blockchain. Now it is time to look closer into the typical contract
structure to understand how different features of the actor model are mapped to
it.</p>
<p>This will not be a step-by-step guide on contract creation, as it is a topic
for the series itself. It would be going through contract elements roughly to
visualize how to handle architecture in the actor model.</p>
<p>Also, we will work with the <code>cw4-group</code> contract from <code>cw-plus</code>, which was written in the old way so
the contract structure will be different than the one we worked on in <code>basics</code> part.
I decided to go with this approach as it visualizes the actor model concept very well.</p>
<h2 id="the-state"><a class="header" href="#the-state">The state</a></h2>
<p>As before we would start with the state. Previously we were working with
the <code>cw4-group</code> contract, so let's start by looking at its code. Go to
<code>cw-plus/contracts/cw4-group/src</code>. The folder structure should look like
this:</p>
<pre><code class="language-bash">  src
  contract.rs
  error.rs
  helpers.rs
  lib.rs
  msg.rs
  state.rs
</code></pre>
<p>As you may already figure out, we want to check the <code>state.rs</code> first.</p>
<p>The most important thing here is a couple of constants: <code>ADMIN</code>, <code>HOOKS</code>,
<code>TOTAL</code>, and <code>MEMBERS</code>. Every one of such constants represents a single portion
of the contract state - as tables in databases. The types of those constants
represent what kind of table this is. The most basic ones are <code>Item&lt;T&gt;</code>, which
keeps zero or one element of a given type, and <code>Map&lt;K, T&gt;</code> which is a key-value
map.</p>
<p>You can see <code>Item</code> is used to keep an admin and some other data: <code>HOOKS</code>, and
<code>TOTAL</code>. <code>HOOKS</code> is used by the <code>cw4-group</code> to allow subscription to any
changes to a group - a contract can be added as a hook, so when the group
changes, a message is sent to it. The <code>TOTAL</code> is just a sum of all members'
weights.</p>
<p>The <code>MEMBERS</code> in the group contract is the <code>SnapshotMap</code> - as you can imagine,
it is a <code>Map</code>, with some steroids - this particular one, gives us access to the
state of the map at some point in history, accessing it by the blockchain
<code>height</code>. <code>height</code> is the count of blocks created since the beggining of
blockchain, and it is the most atomic time representation in smart contracts.
There is a way to access the clock time in them, but everything happening in a
single block is considered happening in the same moment.</p>
<p>Other types of storage objects not used in group contracts are:</p>
<ul>
<li><code>IndexedMap</code> - another map type, that allows accessing values
by a variety of keys</li>
<li><code>IndexedSnapshotMap</code> - <code>IndexedMap</code> and <code>SnapshotMap</code> married</li>
</ul>
<p>What is very important - every state type in the contract is accessed using
some name. All of those types are not containers, just accessors to the state.
Do you remember that I told you before that blockchain is our database? And
that is correct! All those types are just ORM to this database - when we use
them to get actual data from it, we pass a special <code>State</code> object to them, so
they can retrieve items from it.</p>
<p>You may ask - why all that data for a contract are not auto-fetched by
whatever is running it. That is a good question. The reason is that we want
contracts to be lazy with fetching. Copying data is a very expensive operation,
and for everything happening on it, someone has to pay - it is realized by gas
cost. I told you before, that as a contract developer you don't need to worry
about gas at all, but it was only partially true. You don't need to know
exactly how gas is calculated, but by lowering your gas cost, you would may
execution of your contracts cheaper which is typically a good thing. One good
practice to achieve that is to avoid fetching data you will not use in a
particular call.</p>
<h2 id="messages"><a class="header" href="#messages">Messages</a></h2>
<p>In a blockchain, contracts communicate with each other by some JSON
messages. They are defined in most contracts in the <code>msg.rs</code> file. Take
a look at it.</p>
<p>There are three types on it, let's go through them one by one.
The first one is an <code>InstantiateMsg</code>. This is the one, that is sent
on contract instantiation. It typically contains some data which
is needed to properly initialize it. In most cases, it is just a
simple structure.</p>
<p>Then there are two enums: <code>ExecuteMsg</code>, and <code>QueryMsg</code>. They are
enums because every single variant of them represents a different
message which can be sent. For example, the <code>ExecuteMsg::UpdateAdmin</code>
corresponds to the <code>update_admin</code> message we were sending previously.</p>
<p>Note, that all the messages are attributed with
<code>#[derive(Serialize, Deserialize)]</code>, and
<code>#[serde(rename_all=&quot;snake_case&quot;)]</code>. Those attributes come from
the <a href="https://serde.rs/">serde</a> crate, and they help us with
deserialization of them (and serialization in case of sending
them to other contracts). The second one is not required,
but it allows us to keep a camel-case style in our Rust code,
and yet still have JSONs encoded with a snake-case style more
typical to this format.</p>
<p>I encourage you to take a closer look at the <code>serde</code> documentation,
like everything there, can be used with the messages.</p>
<p>One important thing to notice - empty variants of those enums,
tend to use the empty brackets, like <code>Admin {}</code> instead of
more Rusty <code>Admin</code>. It is on purpose, to make JSONs cleaner,
and it is related to how <code>serde</code> serializes enum.</p>
<p>Also worth noting is that those message types are not set in stone,
they can be anything. This is just a convention, but sometimes
you would see things like <code>ExecuteCw4Msg</code>, or similar. Just keep
in mind, to keep your message name obvious in terms of their
purpose - sticking to <code>ExecuteMsg</code>/<code>QueryMsg</code> is generally a good
idea.</p>
<h2 id="entry-points-1"><a class="header" href="#entry-points-1">Entry points</a></h2>
<p>So now, when we have our contract message, we need a way to handle
them. They are sent to our contract via entry points. There are
three entry points in the <code>cw4-group</code> contract:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg_attr(not(feature = &quot;library&quot;), entry_point)]
pub fn instantiate(
    deps: DepsMut,
    env: Env,
    _info: MessageInfo,
    msg: InstantiateMsg,
) -&gt; Result&lt;Response, ContractError&gt; {
    // ...
}
#[cfg_attr(not(feature = &quot;library&quot;), entry_point)]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -&gt; Result&lt;Response, ContractError&gt; {
    // ..
}
#[cfg_attr(not(feature = &quot;library&quot;), entry_point)]
pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
    // ..
}
<span class="boring">}
</span></code></pre></pre>
<p>Those functions are called by the CosmWasm virtual machine when
a message is to be handled by contract. You can think about them
as the <code>main</code> function of normal programs, except they have a signature
that better describes the blockchain itself.</p>
<p>What is very important is that the names of those entry points (similarly to
the <code>main</code> function) are fixed - it is relevant, so the virtual machine knows
exactly what to call.</p>
<p>So, let's start with the first line. Every entry point is attributed with
<code>#[cfg_attr(not(feature = &quot;library&quot;), entry_point)]</code>. It may look a bit
scary, but it is just a conditional equivalent of <code>#[entry_point]</code> -
the attribute would be there if and only if the &quot;library&quot; feature is not set.
We do this to be able to use our contracts as dependencies for other
contracts - the final binary can contain only one copy of each entry point,
so we make sure, that only the top-level one is compiled without this
feature.</p>
<p>The <code>entry_point</code> attribute is a macro that generates some boilerplate.
As the binary is run by WASM virtual machine, it doesn't know much about
Rust types - the actual entry point signatures are very inconvenient to
use. To overcome this issue, there is a macro created, which generates
entry points for us, and those entry points are just calling our functions.</p>
<p>Now take a look at functions arguments. Every single entry point takes as
the last argument a message which triggered the execution of it (except for
<code>reply</code> - I will explain it later). In addition to that, there are
additional arguments provided by blockchain:</p>
<ul>
<li><code>Deps</code> or <code>DepsMut</code> object is the gateway to the world outside the smart contract context. It allows
accessing the contract state, as well as querying other contracts, and
also delivers an <code>Api</code> object with a couple of useful utility functions.
The difference is that <code>DepsMut</code> allows updating state, while <code>Deps</code>
allows only to look at it.</li>
<li><code>Env</code> object delivers information about the blockchain state at the
moment of execution - its height, the timestamp of execution and information
about the executing contract itself.</li>
<li><code>MessageInfo</code> object is information about the contract call - it
contains the address which sends the message, and the funds sent with the
message.</li>
</ul>
<p>Keep in mind, that the signatures of those functions are fixed (except
the messages type), so you cannot interchange <code>Deps</code> with <code>DepsMut</code> to
update the contract state in the query call.</p>
<p>The last portion of entry points is the return type. Every entry point returns
a <code>Result</code> type, with any error which can be turned into a string - in case of
contract failure, the returned error is just logged. In most cases, the error
type is defined for a contract itself, typically using a
<a href="https://docs.rs/thiserror/latest/thiserror/">thiserror</a> crate. <code>Thiserror</code> is
not required here, but is strongly recommended - using it makes the error
definition very straightforward, and also improves the testability of the
contract.</p>
<p>The important thing is the <code>Ok</code> part of <code>Result</code>. Let's start with the
<code>query</code> because this one is the simplest. The query always returns the <code>Binary</code>
object on the <code>Ok</code> case, which would contain just serialized response.
The common way to create it is just calling a <code>to_binary</code> method
on an object implementing <code>serde::Serialize</code>, and they are typically
defined in <code>msg.rs</code> next to message types.</p>
<p>Slightly more complex is the return type returned by any other entry
point - the <code>cosmwasm_std::Response</code> type. This one keep everything
needed to complete contract execution. There are three chunks of
information in that.</p>
<p>The first one is an <code>events</code> field. It contains all events, which would
be emitted to the blockchain as a result of the execution. Events have
a really simple structure: they have a type, which is just a string,
and a list of attributes which are just string-string key-value pairs.</p>
<p>You can notice that there is another <code>attributes</code> field on the <code>Response</code>.
This is just for convenience - most executions would return
only a single event, and to make it a bit easier to operate one, there
is a set of attributes directly on response. All of them would be converted
to a single <code>wasm</code> event which would be emitted. Because of that, I consider
<code>events</code> and <code>attributes</code> to be the same chunk of data.</p>
<p>Then we have the messages field, of <code>SubMsg</code> type. This one is the clue
of cross-contact communication. Those messages would be sent to the
contracts after processing. What is important - the whole execution is
not finished, unless the processing of all sub-messages scheduled by the contract
finishes. So, if the group contract sends some messages as a result of
<code>update_members</code> execution, the execution would be considered done only if
all the messages sent by it would also be handled (even if they failed).</p>
<p>So, when all the sub-messages sent by contract are processed, then all the
attributes generated by all sub-calls and top-level calls are collected and
reported to the blockchain. But there is one additional piece of information -
the <code>data</code>. So, this is another <code>Binary</code> field, just like the result of a query
call, and just like it, it typically contains serialized JSON. Every contract
call can return some additional information in any format. You may ask - in
this case, why do we even bother returning attributes? It is because of a
completely different way of emitting events and data. Any attributes emitted by
the contract would be visible on blockchain eventually (unless the whole
message handling fails). So, if your contract emitted some event as a result of
being sub-call of some bigger use case, the event would always be there visible
to everyone. This is not true for data. Every contract call would return only
a single <code>data</code> chunk, and it has to decide if it would just forward the <code>data</code>
field of one of the sub-calls, or maybe it would construct something by itself.
I would explain it in a bit more detail in a while.</p>
<h2 id="sending-submessages"><a class="header" href="#sending-submessages">Sending submessages</a></h2>
<p>I don't want to go into details of the <code>Response</code> API, as it can be read
directly from documentation, but I want to take a bit closer look at the part
about sending messages.</p>
<p>The first function to use here is <code>add_message</code>, which takes as an argument the
<code>CosmosMsg</code> (or rather anything convertible to it). A message added to response
this way would be sent and processed, and its execution would not affect the
result of the contract at all.</p>
<p>The other function to use is <code>add_submessage</code>, taking a <code>SubMsg</code> argument. It
doesn't differ much from <code>add_message</code> - <code>SubMsg</code> just wraps the <code>CosmosMsg</code>,
adding some info to it: the <code>id</code> field, and <code>reply_on</code>. There is also a
<code>gas_limit</code> thing, but it is not so important - it just causes sub-message
processing to fail early if the gas threshold is reached.</p>
<p>The simple thing is <code>reply_on</code> - it describes if the <code>reply</code> message should be
sent on processing success, on failure, or both.</p>
<p>The <code>id</code> field is an equivalent of the order id in our KFC example from the
very beginning. If you send multiple different sub-messages, it would be
impossible to distinguish them without that field. It would not even be
possible to figure out what type of original message reply handling is! This is
why the <code>id</code> field is there - sending a sub-message you can set it to any
value, and then on the reply, you can figure out what is happening based on
this field.</p>
<p>An important note here - you don't need to worry about some sophisticated way
of generating ids. Remember, that the whole processing is atomic, and only one
execution can be in progress at once. In most cases, your contract sends a
fixed number of sub-messages on very concrete executions. Because of that, you
can hardcode most of those ids while sending (preferably using some constant).</p>
<p>To easily create submessages, instead of setting all the fields separately,
you would typically use helper constructors: <code>SubMsg::reply_on_success</code>,
<code>SubMsg::reply_on_error</code> and <code>SubMsg::reply_always</code>.</p>
<h2 id="cosmosmsg"><a class="header" href="#cosmosmsg">CosmosMsg</a></h2>
<p>If you took a look at the <code>CosmosMsg</code> type, you could be very surprised - there
are so many variants of them, and it is not obvious how they relate to
communication with other contracts.</p>
<p>The message you are looking for is the <code>WasmMsg</code> (<code>CosmosMsg::Wasm</code> variant).
This one is very much similar to what we already know - it has a couple of
variants of operation to be performed by contracts: <code>Execute</code>, but also
<code>Instantiate</code> (so we can create new contracts in contract executions), and also
<code>Migrate</code>, <code>UpdateAdmin</code>, and <code>ClearAdmin</code> - those are used to manage
migrations (will tell a bit about them at the end of this chapter).</p>
<p>Another interesting message is the <code>BankMsg</code> (<code>CosmosMsg::Bank</code>). This one
allows a contract to transfer native tokens to other contracts (or burn them -
equivalent to transferring them to some black whole contract). I like to think
about it as sending a message to a very special contract responsible for handling
native tokens - this is not a true contract, as it is handled by the blockchain
itself, but at least to me it simplifies things.</p>
<p>Other variants of <code>CosmosMsg</code> are not very interesting for now. The <code>Custom</code>
one is there to allow other CosmWasm-based blockchains to add some
blockchain-handled variant of the message. This is a reason why most
message-related types in CosmWasm are generic over some <code>T</code> - this is just a
blockchain-specific type of message. We will never use it in the <code>wasmd</code>. All
other messages are related to advanced CosmWasm features, and I will not
describe them here.</p>
<h2 id="reply-handling"><a class="header" href="#reply-handling">Reply handling</a></h2>
<p>So now that we know how to send a submessage, it is time to talk about
handling the reply. When sub-message processing is finished, and it is
requested to reply, the contract is called with an entry point:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg_attr(not(feature = &quot;library&quot;), entry_point)]
pub fn reply(deps: DepsMut, env: Env, msg: Reply) -&gt; Result&lt;Response, ContractError&gt; {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>DepsMut</code>, and <code>Env</code> arguments are already familiar, but there is a new
one, substituting the typical message argument: the <code>cosmwasm_std::Reply</code>.</p>
<p>This is a type representing the execution status of the sub-message. It is
slightly processed <code>cosmwasm_std::Response</code>. The first important thing it contains
is an <code>id</code> - the same, which you set sending sub-message, so now you can
identify your response. The other one is the <code>ContractResult</code>, which is very
similar to the Rust <code>Result&lt;T, String&gt;</code> type, except it is there for
serialization purposes. You can easily convert it into a <code>Result</code> with an
<code>into_result</code> function.</p>
<p>In the error case of <code>ContracResult</code>, there is a string - as I mentioned
before, errors are converted to strings right after execution. The <code>Ok</code> case
contains <code>SubMsgExecutionResponse</code> with two fields: <code>events</code> emitted by
sub-call, and the <code>data</code> field embedded on response.</p>
<p>As said before, you never need to worry about forwarding events - CosmWasm
would do it anyway. The <code>data</code> however, is another story. As mentioned before,
every call would return only a single data object. In the case of sending
sub-messages and not capturing a reply, it would always be whatever is returned
by the top-level message. But it is not the case when <code>reply</code> is called. If a
a reply is called, then it is a function deciding about the final <code>data</code>. It can
decide to either forward the data from the sub-message (by returning <code>None</code>) or
to overwrite it. It cannot choose, to return data from the original execution
processing - if the contract sends sub-messages waiting for replies, it is
supposed to not return any data, unless replies are called.</p>
<p>But what happens if multiple sub-messages are sent? What would the final
<code>data</code> contain? The rule is - the last non-None. All sub-messages are always
called in the order of adding them to the <code>Response</code>. As the order is
deterministic and well defined, it is always easy to predict which reply would
be used.</p>
<h2 id="migrations"><a class="header" href="#migrations">Migrations</a></h2>
<p>I mentioned migrations earlier when describing the <code>WasmMsg</code>. So, migration
is another action possible to be performed by contracts, which is kind
of similar to instantiate. In software engineering, it is a common thing to
release an updated version of applications. It is also a case in the blockchain -
SmartContract can be updated with some new features. In such cases, a new
code is uploaded, and the contract is migrated - so it knows that from
this point, its messages are handled by another, updated contract code.</p>
<p>However, it may be that the contract state used by the older version of the
contract differs from the new one. It is not a problem if some info was
added (for example some additional map - it would be just empty right
after migration). But the problem is, when the state changes,
for example, the field is renamed. In such a case, every contract execution
would fail because of (de)serialization problems. Or even more subtle
cases, like adding a map, but one which should be synchronized with the whole
contract state, not empty.</p>
<p>This is the purpose of the <code>migration</code> entry point. It looks like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg_attr(not(feature = &quot;library&quot;), entry_point)]
pub fn migrate(deps: DepsMut, env: Env, msg: MigrateMsg) -&gt; Result&lt;Response&lt;T&gt;, ContracError&gt; {
    // ..
}
<span class="boring">}
</span></code></pre></pre>
<p><code>MigrateMsg</code> is the type defined by the contract in <code>msg.rs</code>.
The <code>migrate</code> entry point would be called at the moment of performing
the migration, and it is responsible for making sure the state is correct
after the migration. It is very similar to schema migrations in traditional
database applications. And it is also kind of difficult, because of version
management involved - you can never assume, that you are migrating a contract
from the previous version - it can be migrated from any version, released
anytime - even later than that version we are migrating to!</p>
<p>It is worth bringing back one issue from the past - the contract admin. Do you
remember the <code>--no-admin</code> flag we set previously on every contract
instantiation? It made our contract unmigrateable. Migrations can be performed
only by contract admin. To be able to use it, you should pass <code>--admin address</code>
flag instead, with the <code>address</code> being the address that would be able to
perform migrations.</p>
<h2 id="sudo"><a class="header" href="#sudo">Sudo</a></h2>
<p>Sudo is the last basic entry point in <code>CosmWasm</code>, and it is the one we would
never use in <code>wasmd</code>. It is equivalent to <code>CosmosMsg::Custom</code>, but instead of
being a special blockchain-specific message to be sent and handled by a
blockchain itself, it is now a special blockchain-specific message sent by the
blockchain to contract in some conditions. There are many uses for those, but I
will not cover them, because would not be related to <code>CosmWasm</code> itself. The
signature of <code>sudo</code> looks like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg_attr(not(feature = &quot;library&quot;), entry_point)]
pub fn sudo(deps: DepsMut, env: Env, msg: SudoMsg) -&gt; Result&lt;Response, ContractError&gt; {
    // ..
}
<span class="boring">}
</span></code></pre></pre>
<p>The important difference is that because <code>sudo</code> messages are blockchain
specific, the <code>SudoMsg</code> type is typically defined by some blockchain helper
crate, not the contract itself.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="legal-information"><a class="header" href="#legal-information">Legal Information</a></h1>
<p>Infomation according to  5 TMG</p>
<h2 id="provider"><a class="header" href="#provider">Provider</a></h2>
<p>Confio GmbH<br />
7th Floor<br />
Potsdamer Platz 1<br />
10785 Berlin</p>
<h2 id="managing-director"><a class="header" href="#managing-director">Managing Director</a></h2>
<p>Simon Warta</p>
<h2 id="contact"><a class="header" href="#contact">Contact</a></h2>
<p><a href="mailto:hello@confio.gmbh">hello@confio.gmbh</a></p>
<h2 id="commercial-register"><a class="header" href="#commercial-register">Commercial Register</a></h2>
<p>HRB 221575, Amtsgericht Charlottenburg</p>
<h2 id="vat-number"><a class="header" href="#vat-number">VAT number</a></h2>
<p>DE339802279</p>
<h2 id="responsible-for-the-content"><a class="header" href="#responsible-for-the-content">Responsible for the content</a></h2>
<p>Simon Warta<br />
c/o Confio GmbH<br />
7th Floor<br />
Potsdamer Platz 1<br />
10785 Berlin</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
